***
Данное руководство было написано для tModLoader вер. 1.4.4, будущей версии tModLoader. В текущей версии tModLoader файлы локализации не будут автоматически обновляться, а некоторые методы, упомянутые в данном руководстве, не существуют. Основные концепции остаются в силе.
***

[Original Page (English) | Изначальная страница (на английском)](https://github.com/tModLoader/tModLoader/wiki/Localization)<br />
[中文版 | Версия на китайском](https://github.com/tModLoader/tModLoader/wiki/zh-Localization-%E6%9C%AC%E5%9C%B0%E5%8C%96)

---

# Что представляет собой локализация?
Локализация или перевод обеспечивает возможность использования модификации пользователями, говорящими на языке, отличном от языка, на котором говорит автор. Каждый фрагмент текста, который пользователь может увидеть во время игры в модификацию, содержится в текстовых файлах, называемых файлами локализации. Например, в ExampleMod есть предмет, который на английском языке называется «Paper Airplane», а на русском - «Бумажный самолётик». Благодаря использованию локализации русскоязычные пользователи могут понимать и наслаждаться содержимым ExampleMod, не изучая английский язык.

С этими файлами локализации легко работать, что позволяет переводить модификации пользователям, не имеющим технических навыков. Затем эти переводы могут быть предоставлены автору или опубликованы в виде новой модификации, что позволит большему числу людей насладиться модификацией.

**Даже если вы не собираетесь лично переводить свою модификацию на другие языки, вам необходимо использовать файлы локализации для того языка, который вы поддерживаете.**

На этой вики-странице рассматриваются вопросы локализации, предназначенные для разработчиков модификаций. Если вы хотите перевести существующую модификацию или предоставить локализацию для самого tModLoader, пожалуйста, ознакомьтесь с [(англ.) вики-страницей вклада в локализацию](https://github.com/tModLoader/tModLoader/wiki/Contributing-Localization).

# Переход с версии 1.4.3 на 1.4.4
Начиная с версии tModLoader 2023.01, все локализации теперь полностью выполняются в файлах `.hjson`. Объявление переводов в коде больше не поддерживается. Это изменение значительно упростит управление локализацией и облегчит создание переводов модификаций. Если вас интересует более подробное обоснование этих изменений, см. [(англ.) предложение по основным изменениям локализации](https://github.com/tModLoader/tModLoader/issues/3074)

**Если вы не используете Git или какую-либо форму контроля версий, то перед продолжением работы рекомендуется сделать резервную копию папки с исходным кодом вашей модификации.**

## Генерация файлов локализации в версии 1.4.3
Для начала нам необходимо использовать старый tModLoader для экспорта файлов локализации. Для перехода на ветку `«Нет»` необходимо использовать Steam. ([(англ.) Инструкция по переключению между версиями tModLoader](https://github.com/tModLoader/tModLoader/wiki/Basic-tModLoader-Usage-FAQ#switch-to-stable-tmodloader-or-to-preview-tmodloader))

После установки нужной версии игры откройте tModLoader, включите модификацию и откройте меню `«Исходники модов»`. Найдите в списке свою модификацию. При наведении на неё вы увидите зелёную стрелку с надписью «Export 1.4.4+ localization files», нажмите её.    
![image](https://user-images.githubusercontent.com/4522492/210681409-a659670d-5908-4e5d-bd45-74c0545f4666.png)    
Теперь перейдите в папку `«ModSources»` и найдите файлы локализации вашей модификации. Если ранее у вас не было файлов локализации, перейдите на верхний уровень папки вашей модификации. Вы должны увидеть только что созданные файлы `.hjson.new`:    
![image](https://user-images.githubusercontent.com/4522492/210681629-8aad2234-bd56-40c8-b03f-7e36b98d4486.png)    
Откройте новые файлы в текстовом редакторе и убедитесь, что они выглядят правильно. В них должны присутствовать все записи, которые ранее были в текущих файлах `.hjson`, а также вновь созданные записи для всего остального содержимого модификации. Если всё выглядит правильно, переходите к следующим шагам.

### Изменённые ключи
Обратите внимание, что многие шаблоны клавиш изменились. Они будут автоматически скорректированы при экспорте, но все пользовательские ключи или код, использующий старый шаблон ключей, придётся исправлять вручную. Например, `Mods.{НазваниеМодификации}.ItemName.{НазваниеСодержимого}` теперь `Mods.{НазваниеМодификации}.Items.{НазваниеСодержимого}.DisplayName`.

<details><summary>Шаблоны изменённых ключей</summary>

```
Mods.{НазваниеМодификации}.DamageClassName.{НазваниеСодержимого}	-->	Mods.{НазваниеМодификации}.DamageClasses.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.InfoDisplayName.{НазваниеСодержимого}	-->	Mods.{НазваниеМодификации}.InfoDisplays.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.BiomeName.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Biomes.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.BuffName.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Buffs.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.BuffDescription.{НазваниеСодержимого}	-->	Mods.{НазваниеМодификации}.Buffs.{НазваниеСодержимого}.Description
Mods.{НазваниеМодификации}.ItemName.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Items.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.ItemTooltip.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Items.{НазваниеСодержимого}.Tooltip
Mods.{НазваниеМодификации}.NPCName.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.NPCs.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.Prefix.{НазваниеСодержимого}			-->	Mods.{НазваниеМодификации}.Prefixes.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.ProjectileName.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Projectiles.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.ResourceDisplaySet.{НазваниеСодержимого}	-->	Mods.{НазваниеМодификации}.ResourceDisplaySets.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.Containers.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Tiles.{НазваниеСодержимого}.ContainerName
Mods.{НазваниеМодификации}.MapObject.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Tiles.{НазваниеСодержимого}.MapEntry
Mods.{НазваниеМодификации}.Keybind.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Keybinds.{НазваниеСодержимого}.DisplayName
```

</details>

## Переход на версию 1.4.4 tModLoader и компилирование модификации
Используйте Steam для перехода на ветку `1.4.4-preview`. ([(англ.) Инструкции по переключению между версиями tModLoader](https://github.com/tModLoader/tModLoader/wiki/Basic-tModLoader-Usage-FAQ#switch-to-stable-tmodloader-or-to-preview-tmodloader))

После запуска tModLoader вы заметите, что ваш мод (и, скорее всего, все остальные включенные вами модификации) не загружается, что вполне ожидаемо. Зайдите в меню «Исходники модов» и нажмите кнопку «Запустить tModPorter». Наряду с другими изменениями, это удалит весь код, использующий старый подход к локализации.     
![image](https://user-images.githubusercontent.com/4522492/210683375-43816104-2812-4db2-bac6-813ebb47a089.png)    
После этого необходимо найти эти файлы `.hjson.new` и использовать их для замены существующих файлов `.hjson`. Для этого сначала удалите текущие файлы `.hjson` (если таковые имеются), а затем переименуйте файлы `.hjson.new` в расширение `.hjson`. (Если вы не можете переименовать расширения файлов, то вам необходимо [включить отображение «Расширения имён файлов»](https://gfycat.com/TheseSameGrasshopper) в системе, чтобы вы могли это сделать.)

Теперь, возможно, потребуется открыть Visual Studio и исправить все оставшиеся проблемы компиляции. После исправления оставшихся проблем можно перекомпилировать модификацию, и она должна заработать. После того как всё заработает, можно найти в исходном коде модификации строки типа `// Tooltip.SetDefault("Это модифицированный предмет.");` или `// DisplayName.SetDefault("Пример меча");` и удалить их. Они больше не будут использоваться. (Чтобы легко найти большинство этих строк, можно выполнить поиск по всем файлам проекта по поисковому запросу `.SetDefault(`)

Для облегчения поиска вызовов (и замены их на пустую строку) можно использовать следующие регулярные выражения. Оба варианта требуют использования такого инструмента, как Notepad++, с включённой опцией «. - новая строка»
- Однострочные комментарии: `\s+// [\w.]+SetDefault\(".+?;`
- Многострочные комментарии: `\s+/\*[\s\w.]+SetDefault\(".+?\*/`

Краткое руководство по Notepad++, чтобы применить это ко всему моду: Откройте любой файл в Notepad++, нажмите ctrl + F, перейдите на вкладку «Найти в файлах», выберите «Регуляр. выражен.» и «. - новая строка» внизу, затем в «Фильтры:» добавьте `*.cs`, для «Папка:» нажмите кнопку справа, чтобы перейти к корневой папке вашей модификации. Наконец, вставьте регулярное выражение в «Найти:» и оставьте «Заменить на:» пустым, затем нажмите «Заменить в файлах». Если вы допустили ошибку, просто нажмите ctrl + Z один раз, чтобы вернуть все изменения. Рекомендуется использовать программы версионирования, такие как git, чтобы иметь возможность вручную вернуть изменения, если это необходимо, и просмотреть результат.

# Процесс локализации
Обновление файлов локализации происходит в конце загрузки модификации. Это означает, что автору необходимо скомпилировать и загрузить модификацию после добавления контента, чтобы файлы локализации обновились. После обновления автор может отредактировать файлы `.hjson` и добавить переводы. После этого мод можно скомпилировать и снова загрузить, чтобы переводы появились в игре.

Во избежание потери работы, пожалуйста, помните о предполагаемом рабочем процессе:

1. Добавьте новое содержимое в модификацию, например, нового `ModItem`
2. Скомпилируйте и перезапустите модификацию
3. К этому моменту файлы `.hjson` будут автоматически обновлены записями для нового содержимого. Отредактируйте файлы `.hjson`, чтобы дать новому содержимому имя на английском
4. Скомпилируйте и перезапустите модификацию
5. Файлы `.hjson` на других языках, кроме английского теперь обновляются с помощью соответствующих заполнителей и могут быть также обновлены переводчиками или создателями модификаций

Если переводчик присылает вам обновлённый файл `.hjson` для непосредственного добавления в модификацию, имейте в виду, что она может быть перезаписана, если модификация загрузится и tModLoader по какой-то причине обнаружит, что файл `.tmod` новее файла `.hjson`. В этом случае лучшим вариантом будет компилирование модификации перед его загрузкой или перезагрузкой. Можно выполнить компилирование в Visual Studio при закрытом tModLoader, а можно пропустить загрузку мода при запуске tModLoader, удерживая клавишу shift, и сразу перейти в меню «Исходники модов» для компилирования модификации. Если вы забыли это сделать и обнаружили, что tModLoader вернул только что переведённые файлы `.hjson` к их старому содержимому, скопируйте обновлённые файлы `.hjson` в папку с исходниками ещё раз, а затем выполните компиляцию и перезагрузку.

## Обновление в реальном времени
tModLoader определяет момент сохранения файлов `.hjson` в папках ModSources и автоматически перезагружает их во время игры. При таком подходе автору не нужно перекомпилировать и перезагружать модификацию для проверки новых значений. Если вы используете эту возможность, не забудьте перекомпилировать модификацию перед публикацией, чтобы все изменения попали в опубликованную версию.

Здесь мы видим эту функцию в действии. Автор редактирует файл `en-US.hjson`, а затем сохраняет его, чтобы изменить английское название и всплывающую подсказку предмета `ExampleWings`. Изменения появляются в игре через пару секунд:    

https://user-images.githubusercontent.com/4522492/229942438-26604fd7-9073-436c-b2ab-d99b4f2efeb7.mp4

# Принцип работы локализации
Каждый фрагмент текста в игре, от названий предметов до слов в главном меню, использует локализацию. Каждый фрагмент текста в игре фактически представляет собой пару данных: ключ локализации и значение локализации. Например, когда игрок создаёт маленький мир, игра использует ключ локализации `UI.WorldSizeSmall` для поиска правильного значения перевода для текущего загруженного языка и выводит пользователю слово «Small», если выбран английский язык. Если выбран другой язык, игра всё равно обращается к `UI.WorldSizeSmall`, но значение локализации будет другим. Поскольку создатели Terraria пишут код на английском языке, большинство ключей локализации очень похожи на их английское значение.

В tModLoader модификации используют файлы `.hjson` для чистого хранения ключей локализации и значений локализации. Каждый язык имеет свой собственный файл `.hjson`. Если вы знакомы с JSON, то эти файлы `.hjson` будут вам знакомы. 

Вот простой пример:

Имя файла: **tModLoader/ModSources/ExampleMod/ru-RU.hjson**
```
Mods: {
	ExampleMod: {
		Items: {
			ExampleItem: {
				DisplayName: Примерный предмет
				Tooltip: Это модифицированный предмет.
			}
		}
	}
}
```

В данном примере мы видим два основных понятия: ключи локализации и переводы локализации. Ключ локализации образуется из комбинации всех текстов, расположенных слева от `:` на каждом уровне вложенности. Текст, расположенный справа от `:`, является значением локализации. В данном примере передаются 2 ключа локализации и соответствующие им значения локализации: `Mods.ExampleMod.Items.ExampleItem.Displayname` соответствует `«Примерный предмет»` и `Mods.ExampleMod.Items.ExampleItem.Tooltip` соответствует `«Это модифицированный предмет.»`. Если синтаксис кажется сложным, не волнуйтесь, авторам не нужно вручную редактировать эти файлы, игра будет обновлять их автоматически.

При загрузке этой модификации tModLoader найдёт все файлы локализации, соответствующие текущему языку, и сохранит их в памяти. Когда игре необходимо вывести текст на экран, используется ключ, который запрашивает сохранённые данные и извлекает нужный текст. Переводы хранятся в памяти в виде объекта `LocalizedText`, авторы могут использовать метод `Language.GetText` для получения объекта `LocalizedText` из ключа локализации. Свойство `Value` может быть использовано для получения значения локализации из объекта `LocalizedText`. В качестве альтернативы метод `Language.GetTextValue` возвращает значение локализации непосредственно из ключа локализации:

```cs
string hivePackDialogue = Language.GetTextValue("Mods.ExampleMod.Dialogue.ExampleTravelingMerchant.HiveBackpackDialogue"); // Непосредственно возвращает текст для отображения, string
или
string hivePackDialogue = Language.GetText("Mods.ExampleMod.Dialogue.ExampleTravelingMerchant.HiveBackpackDialogue").Value; // Возвращает LocalizedText, для получения string использует его свойство Value.
или
LocalizedText hivePackDialogueLocalizedText = Language.GetText("Mods.ExampleMod.Dialogue.ExampleTravelingMerchant.HiveBackpackDialogue"); // Возвращает LocalizedText
string hivePackDialogue = hivePackDialogueLocalizedText.Value; // Присваивает Value вновь объявленной string.
```

## Ключи локализации
tModLoader автоматически назначает ключи перевода для большинства содержимого. Шаблон ключа - `Mods.{НазваниеМодификации}.{Категория}.{НазваниеСодержимого}.{НазваниеДанных}`, где `«НазваниеМодификации»` - внутреннее имя модификации, `«Категория»` определяется типом содержимого, `«НазваниеСодержимого»` - внутреннее имя содержимого (обычно имя класса), а `«НазваниеДанных»` определяет ключ внутри класса. 

Например, `ModItem` имеет `категорию`, установленную на `Items`. Он также имеет 2 отдельных элемента данных, `DisplayName` и `Tooltip`. Если модификация с именем `ExampleMod` добавляет класс `ModItem` с именем `ExampleItem`, то будут созданы и добавлены в файлы `.hjson` два ключа: `Mods.ExampleMod.Items.ExampleItem.DisplayName` и `Mods.ExampleMod.Items.ExampleItem.Tooltip`.

## Заменители
Если в файлах локализации есть текст, который часто повторяется, или если вы хотите использовать существующий текст в игре, то для поддержания чистоты и порядка в файлах локализации можно использовать замены. Замены имеют форму `{$КлючТут}` в значениях локализации. При загрузке игры эти разделы будут заменены локализованным текстом, соответствующим указанному ключу.

Например, в игре уже есть перевод текста `«Нажмите правую клавишу мыши, чтобы открыть»`, хранящийся в ключе `CommonItemTooltip.RightClickToOpen`. Модификация может использовать заменители для повторного использования этого значения. Запись `Tooltip: "{$CommonItemTooltip.RightClickToOpen}"` будет содержать текст `«Нажмите правую клавишу мыши, чтобы открыть»` на языке пользователя этого предмета. Другие существующие переводы, такие как названия элементов и другие общие всплывающие подсказки, также доступны для использования.

Также можно использовать переводы из самого мода. Например, в [(англ.) файлах локализации ExampleMod](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Localization/en-US.hjson), `MapObject.ExamplePylonTile: "{$Mods.ExampleMod.ItemName.ExamplePylonItem}"` используется для повторного использования переводов, содержащихся в ключе `Mods.ExampleMod.ItemName.ExamplePylonItem`.

Многие заменители содержат `{0}` или `{1}`, которые являются заполнителями для значений, которые могут предоставить авторы. Эта функция описана в разделе [«Форматирования строк»](#Форматирование-строк).

### Всплывающие подсказки существующих предметов (Tooltip)
Использование существующих подсказок, предоставляемых игрой, в предметах модификации - хорошая идея. Использование единого языка и существующих переводов делает вашу модификацию более привлекательной для большего количества людей. Разверните раздел ниже, чтобы просмотреть список существующих общих подсказок. Помните, что ключ для всех этих подсказок начинается с `CommonItemTooltip.`. 

<details><summary>Ключи CommonItemTooltip</summary>

```
// Добавлено разработчиками Terraria
"UsesLife": "Использует {0} ед. здоровья",
"UsesMana": "Использует {0} ед. маны",
"RestoresLife": "Восстанавливает {0} ед. здоровья",
"RestoresLifeRange": "Восстанавливает жизнь на {0}-{1}",
"RestoresMana": "Восстанавливает {0} ед. маны",
"MinuteDuration": "Длительность {0} мин.",
"SecondDuration": "Длительность {0} с",
"PlaceableOnXmasTree": "Надевается на новогоднюю ель",
"String": "Увеличивает дистанцию действия йо-йо",
"Counterweight": "Бросает противовес после попадания йо-йо по врагу",
"BannerBonus": "Игроки поблизости получают бонус против: ",
"BannerBonusReduced": "Игроки поблизости получают небольшой бонус против: ",
"SpecialCrafting": "Используется для создания особых предметов",
"DevItem": "Отлично подходит, чтобы впечатлить разработчиков!",
"FlightAndSlowfall": "Позволяет летать и замедляет падение",
"PressDownToHover": "Нажмите ВНИЗ, чтобы включить парение\nНажмите ВВЕРХ, чтобы отключить парение",
"PressUpToBooster": "Удерживайте ВВЕРХ, чтобы ускориться еще больше!",
"RightClickToOpen": "Нажмите <right>, чтобы открыть",
"RightClickToClose": "Нажмите <right>, чтобы закрыть",
"MinorStats": "Немного повышает все характеристики",
"MediumStats": "Умеренно повышает все характеристики",
"MajorStats": "Сильно повышает все характеристики",
"TipsyStats": "Небольшое увеличение параметров ближнего боя и сниженная защита",
"EtherianManaCost10": "Стоит 10 единиц Этерианской маны за каждое использование в борьбе с Этерианским кристаллом",
"GolfBall": "Можно ударить клюшкой для гольфа",
"Sentry": "Призывает часового",
"GolfIron": "Закругленная клюшка, идеальная для ударов на средние дистанции\nМячи для гольфа летят на хорошее расстояние с приличным подъемом",
"GolfPutter": "Специальная клюшка для последних лунок\nМячи для гольфа летят на короткие дистанции и остаются близко к земле для точных ударов",
"GolfWedge": "Специальная клюшка для бункеров с песком или высоких препятствий\nМячи для гольфа очень сильно поднимаются вверх, но летят недалеко",
"GolfDriver": "Прочная клюшка для ударов на дальние дистанции\nМячи для гольфа летят очень далеко с небольшим подъемом",
"Kite": "Змеев можно запускать в ветреные дни\nСматывайте веревку с помощью <right>",
"LavaFishing": "Позволяет ловить рыбу в лаве",
"CreativeSacrificeNeeded": "Исследуйте еще {0}, чтобы разблокировать дублирование",
"CreativeSacrificeComplete": "Дублирование разблокировано",
"TeleportationPylon": "Телепортируйтесь к другому столбу, когда 2 поселенца будут рядом\nВы можете поставить только один столб в каждом биоме",
"Whips": "Ваши призванные существа будут стараться атаковать врагов",
"WizardHatDuringAnniversary": "Увеличивает ваше максимальное количество питомцев на 1",
"MechSummonDuringEverything": "«Часть комплекта»",
"MechdusaSummonNotDuringEverything": "«Не действует в этом мире»",
"LuminiteVariant": "«Запрещенный строительный материал из загробного мира»"

// Добавлено разработчиками tModLoader
"IncreasesMaxLifeBy": "Увеличивает максимальный уровень здоровья на {0} ед.",
"IncreasesMaxManaBy": "Увеличивает максимальный уровень маны на {0} ед.",
"IncreasesMaxLifeByPercent": "Увеличивает максимальный уровень здоровья на {0} %",
"IncreasesMaxManaByPercent": "Увеличивает максимум уровень маны на {0} %",

"IncreasesBowDamageByPercent": "Увеличивает урон от стрел на {0} %",
"IncreasesGunDamageByPercent": "Увеличивает урон от пушек на {0} %",
"IncreasesSpecialistDamageByPercent": "Увеличивает урон от особого дальнобойного оружия на {0} %",

"IncreasesWhipRangeByPercent": "Увеличивает дальность удара кнутом на {0} %",
"IncreasesMaxMinionsBy": "Увеличивает максимальное число ваших прислужников на {0}",
"IncreasesMaxSentriesBy": "Увеличивает урон призываемых существ на {0}",

"IncreasesFishingPowerBy": "Увеличивает мастерство рыбалки на {0}",

"PermanentlyIncreasesMaxLifeBy": "Навсегда увеличивает максимальный уровень здоровья на {0} ед.",
"PermanentlyIncreasesMaxManaBy": "Навсегда увеличивает максимальный уровень маны на {0} ед.",

"ReducesDamageTakenByPercent": "Получаемый урон снижен на {0} %",

"PercentChanceToSaveAmmo": "Шанс {0} % сохранить боеприпасы",
"PercentReducedManaCost": "Уменьшает стоимость в мане на {0} %",

"PercentIncreasedMiningSpeed": "Увеличивает скорость добычи на {0} %",
"PercentIncreasedMovementSpeed": "Увеличивает скорость движения на {0} %",

"ArmorPenetration": "{0} пробивания брони",
"PercentIncreasedDamage": "Увеличивает урон на {0} %",
"PercentIncreasedCritChance": "Увеличивает шанс критического удара на {0} %",
"PercentIncreasedDamageCritChance": "Увеличивает на {0} % урон и шанс критического удара",

"PercentIncreasedMagicDamage": "Увеличивает магический урон на {0} %",
"PercentIncreasedMagicCritChance": "Увеличивает шанс критического магического урона на {0} %",
"PercentIncreasedMagicDamageCritChance": "Увеличивает на {0} % магический урон и шанс критического удара",

"PercentIncreasedMeleeDamage": "Увеличивает урон в ближнем бою на {0} %",
"PercentIncreasedMeleeCritChance": "Увеличивает шанс критического урона в ближнем бою на {0} %",
"PercentIncreasedMeleeDamageCritChance": "Увеличивает на {0} % урон в ближнем бою и шанс критического удара",
"PercentIncreasedMeleeSpeed": "Увеличивает скорость ближнего боя на {0} %",

"PercentIncreasedRangedDamage": "Увеличивает дистанционный урон на {0} %",
"PercentIncreasedRangedCritChance": "Увеличивает шанс критического дистанционного урона на {0} %",
"PercentIncreasedRangedDamageCritChance": "Увеличивает на {0} % дистанционный урон и шанс критического удара",

"PercentIncreasedSummonDamage": "Увеличивает урон призываемых существ на {0} %",
"SummonTagDamage": "Увеличивает урон призываемых существ на {0} ед.",
"PercentSummonTagCritChance": "Увеличивает шанс критического удара призываемых существ на {0} %"
```

</details>

### Прочие существующие переводы

Помимо ключей перевода `CommonItemTooltip.`, предназначенных для подсказок предметов, авторы могут ссылаться на любые другие ключи перевода в игре. Например, `NPCName.BlueSlime` - это ключ, позволяющий получить локализованное имя синего слизня. Авторы могут просмотреть все ключи локализации, скачав файл `.CSV`, упомянутый в разделе [(англ.) руководства Мастерской по расширенных языковым пакетам Terraria](https://forums.terraria.org/index.php?threads/the-ultimate-guide-to-content-creation-and-use-for-the-terraria-workshop.100652/#advancedlanguagepack). 

Обратите внимание, что ключи перевода модификаций не соответствуют шаблону ключей, используемых в Terraria. Например, ключ перевода `PartyZombie` в ExampleMod имеет значение `Mods.ExampleMod.NPCs.PartyZombie.DisplayName`. Ключ перевода содержимого мода не обязательно будет следовать шаблону по умолчанию, поэтому не следует писать код с таким допущением.

### Упрощение области видимости

Если заменяющие ключи имеют общую область видимости со значением ключа локализации, в котором они используются, то заменяющий ключ может быть упрощён. Например, в [(англ.) файлах локализации ExampleMod](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Localization/en-US.hjson) значение ключа `Mods.ExampleMod.ExamplePetItem.DisplayName` установлено в `"{$Common.PaperAirplane}"`. В этом случае игра знает, что нужно проверить наличие ключей в текущей области видимости, в результате чего значение ключа `Mods.ExampleMod.Common.PaperAirplane` будет найдено и подставлено. Используя эту технику, можно, например, опустить `Mods.ModName` из ключей замены.

### Переопределение ключей локализации содержимого
Если многие элементы модификации имеют общий перевод, можно сделать так, чтобы все они указывали на один и тот же ключ перевода. Для этого переопределите свойство и верните результат `Language.GetText`, используя тот ключ перевода, который вы хотите использовать:
```cs
public override LocalizedText Tooltip => Language.GetOrRegister("Mods.ExampleMod.Common.SomeSharedTooltip"); // Переопределяет свойство Tooltip класса в нужный вам LocalizedText.
```
Если вы используете наследование, вам нужно сделать это только в базовом классе и даже можете переопределить это в дочерних классах, если определённый дочерний класс нуждается в другой локализации. О том, как добавить дополнительные локализации к содержимому, помимо свойств по умолчанию, предоставляемых tModLoader, читайте в разделе [«Добавление свойств локализации»](#добавление-свойств-локализации).

Авторы могут использовать `public override LocalizedText Tooltip => LocalizedText.Empty;`, чтобы указать, что ключ перевода не должен создаваться. Это позволяет сделать файлы локализации чище.

## Форматирование строк
Авторы могут использовать [форматирование строк](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.format?view=net-7.0#insert-a-string), чтобы оставлять в переводах места для заполнения текстом при использовании. Это обычная особенность языка программирования c#. Авторы могут использовать метод `string.Format` или перегрузки `Language.GetTextValue` для использования форматирования строк. Более подробная информация об этом содержится в [(англ.) разделе Placeholders](https://github.com/tModLoader/tModLoader/wiki/Contributing-Localization#placeholders). 

### Привязка значений к локализациям
Во многих элементах перевода присутствуют заполнители типа `{0}` или `{1}`, указывающие на места, где автор может указать значение. Например, ключ перевода `CommonItemTooltips.IncreasesMaxMinionsBy` имеет значение `«Увеличивает максимальное число ваших прислужников на {0}»`. Для того чтобы использовать это значение в предмете аксессуара, необходимо указать число, которое будет использоваться вместо `{0}`.

Во-первых, в файле `.hjson` мы назначаем всплывающую подсказку для нашего элемента:
```
ExampleMinionBoostAccessory: {
	DisplayName: Усилитель прислужников
	Tooltip: "{$CommonItemTooltip.IncreasesMaxMinionsBy}"
}
```

Далее нам необходимо «привязать» к этой подсказке наше предполагаемое значение. Этот аксессуар должен увеличивать максимальное количество прислужников на 3. Для этого мы переопределим свойство `Tooltip` и вызовем метод `WithFormatArgs` на исходной подсказке. Это позволит заполнить заполнитель указанным значением. Мы рекомендуем использовать в классе поле `static int` для хранения этих статистических данных. В приведённом ниже примере `MaxMinionIncrease` используется в двух разных местах. Использование поля позволяет автору одновременно изменять поведение и всплывающую подсказку. Такой подход позволяет избежать опечаток, которые могут привести к рассинхронизации подсказки и поведения.

```cs
public class ExampleMinionBoostAccessory : ModItem
{
	public static int MaxMinionIncrease = 3; // Хранить значения в статическом поле

	public override LocalizedText Tooltip => base.Tooltip.WithFormatArgs(MaxMinionIncrease); // Переписать Tooltip и передать значение

	public override void UpdateEquip(Player player) {
		player.maxMinions += MaxMinionIncrease; // Увеличить количество прислужников, которых может иметь игрок, на три
	}
	
	// другой код...
}
```
### Многочисленные форматируемые заменители
Когда локализация ссылается на несколько заменителей, может возникнуть проблема повторяющихся заполнителей. Например, аксессуар, использующий `CommonItemTooltip.IncreasesMaxManaBy` и `CommonItemTooltip.IncreasesMaxMinionsBy`, обнаружит, что они оба используют заполнитель `{0}`. Попытка привязать значения к всплывающей подсказке, использующей обе эти текстовые заменители, не будет работать без дополнительной работы. Авторы могут использовать специальный синтаксис для смещения индексов в пределах определённого ключа заменителя. Добавление символа `@`, за которым следует число, после ключа-заменителя увеличивает количество мест в этом ключе на указанное число. Вкратце, синтаксис выглядит так: `{$КлючТут@ЗначениеСмещенияТут}`. В качестве наглядного примера этой возможности можно привести пример [ExampleBreastplate.cs](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Content/Items/Armor/ExampleBreastplate.cs):

**Существующие записи CommonItemTooltip**
```
"CommonItemTooltip": {
	"IncreasesMaxManaBy": "Increases maximum mana by {0}",
	"IncreasesMaxMinionsBy": "Increases your max number of minions by {0}",
	// и так далее
```

**ExampleMod/Localization/en-US.hjson**
```
ExampleBreastplate: {
	DisplayName: Example Breastplate
	Tooltip:
		'''
		This is a modded body armor.
		Immunity to 'On Fire!'
		{$CommonItemTooltip.IncreasesMaxManaBy}
		{$CommonItemTooltip.IncreasesMaxMinionsBy@1}
		'''
}
```

**ExampleMod/Content/Items/Armor/ExampleBreastplate.cs**
```cs
public class ExampleBreastplate : ModItem
{
	public static int MaxManaIncrease = 20;
	public static int MaxMinionIncrease = 1;

	public override LocalizedText Tooltip => base.Tooltip.WithFormatArgs(MaxManaIncrease, MaxMinionIncrease);

	public override void UpdateEquip(Player player) {
		player.buffImmune[BuffID.OnFire] = true; // Делает игрока невосприимчивым к огню!
		player.statManaMax2 += MaxManaIncrease; // Увеличение количества единиц маны на 20
		player.maxMinions += MaxMinionIncrease; // Увеличение количества прислужников, которых может иметь игрок, на один
	}
}
```
Из этого примера видно, что `Tooltip.WithFormatArgs(MaxManaIncrease, MaxMinionIncrease)` пытается привязать `MaxManaIncrease` к `{0}`, а `MaxMinionIncrease` к `{1}`. Поскольку в записи локализации к `{$CommonItemTooltip.IncreasesMaxMinionsBy@1}` было добавлено `@1`, исходное значение `{0}` было интерпретировано как `{1}`, что позволило игре привязать значение `MaxMinionIncrease` к нужному месту в тексте всплывающей подсказки.

Это может показаться несколько сложным, проще вообще игнорировать заменитель текста и `WithFormatArgs` и просто набирать текст подсказки непосредственно в файле локализации, но преимущества такого подхода могут быть значительными при правильном использовании. При таком подходе большая часть вашего мода будет автоматически локализована на другие языки. Кроме того, такой подход значительно снижает вероятность того, что опечатка приведёт к путанице в дальнейшем.

Ещё более сложный пример использования этой функции см. в [ExampleStatBonusAccessory.cs](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Content/Items/Accessories/ExampleStatBonusAccessory.cs) и соответствующей записи [en-US.hjson](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Localization/en-US.hjson#L160).

### Комбинирование переводов для динамического содержимого
В редких ситуациях может потребоваться перевод, в котором упоминается название содержимого другой модификации, но создать конкретный перевод невозможно, поскольку комбинации создаются во время выполнения.

**СОВЕТ:** 
> Избегайте соблазна создавать комбинированные переводы только потому, что английский язык всегда следует определённому шаблону, поскольку не во всех языках может существовать подходящий шаблон. Вместо этого постарайтесь сделать как можно больше уникальных и подробных переводов. Например, может возникнуть соблазн сделать `Mini-{0}` и подставить названия классов урона (`Sentry`) и т.д. Это сработает в английском языке, но в других языках может потребоваться изменение структуры фразы или добавление дополнительной грамматики, основанной на заменителе. Например, `Mini-Sentry` может переводиться как `«Мини-часовой»`, но слово часовой будет с заглавной буквы.

Классическим примером может служить модификация, автоматически добавляющая бесконечные патроны к каждому элементу боекомплекта в игре. `WithFormatArgs` может принимать в качестве параметров другие `LocalizedText`. Вы также можете переопределить свойство `LocalizedText`, чтобы вернуть совершенно другой `LocalizedText` (см. `Tooltip` в примере ниже)
```
InfiniteAmmoItem.DisplayName: "Infinite {0}"
```

```cs
public class InfiniteAmmoItem : ModItem
{
    Item baseAmmoItem;
    
    public override LocalizedText DisplayName => base.DisplayName.WithFormatArgs(baseAmmoItem.DisplayName);

    public override LocalizedText Tooltip => baseAmmoItem.Tooltip;
}
```

### Использование ModConfig
Атрибуты `Label` и `Tooltip`, используемые в элементах `ModConfig`, могут быть снабжены текстовыми заменителями аналогичным образом. Через атрибуты `LabelArgs` и `TooltipArgs` можно передавать значения соответствующему переводу. Обратите внимание, что строки, начинающиеся с «$», интерпретируются как ключи перевода. Эту возможность демонстрируют примеры `InterpolatedTextA`, `InterpolatedTextB` и `InterpolatedTextC` в [ModConfigShowcaseLabels.cs](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Common/Configs/ModConfigShowcases/ModConfigShowcaseLabels.cs).

## Множественное число
При использовании заполнителей для чисел, например, в `{0} minutes ago`, в английском языке возникают проблемы, когда число равно 1. Если число равно 1, то в тексте должно быть написано «1 minute ago», а не «1 minutes ago». Эта проблема может быть решена с помощью множественного числа. Более подробная информация об этой возможности содержится в [(англ.) разделе Plurals](https://github.com/tModLoader/tModLoader/wiki/Contributing-Localization#plurals). 

## Метки чата (Chat tag)
Значки цветов и элементов могут быть добавлены к значениям локализации с помощью [(англ.) меток чата Tags](https://terraria.wiki.gg/wiki/Chat#Tags). В качестве примера можно привести `ExampleTooltipsItem` в [(англ.) файлах локализации ExampleMod](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Localization/en-US.hjson).

# Автоматические файлы локализации
tModLoader будет автоматически обновлять файлы `.hjson` при появлении нового содержимого или ключей перевода. Английские файлы будут использоваться в качестве шаблона для других языков, которые будут автоматически наследовать комментарии и оформление. 

Обратите внимание, что файлы локализации будут обновляться только в тех случаях, когда игра сочтёт это целесообразным, для повышения эффективности. Например, модификация должна существовать в папке `ModSources`. Загружаемая модификация также должна быть локально скомпилированной. Файлы локализации будут обновляться только в том случае, если временная метка изменения файла старше, чем сама модификация или все модификации, на которые ссылается модификация. Помните, что прямое тестирование старого файла `.tmod` может привести к перезаписи файлов `.hjson` старым содержимым, поэтому рекомендуется использовать Git или создавать резервные копии исходного кода модификации, чтобы можно было восстановить файлы. 

## Добавление содержимого
Когда автор добавляет в свою модификацию новое содержимое, например, `ModItem`, это содержимое изначально не будет локализовано. Автор должен скомпилировать и перезагрузить свою модификацию. После загрузки модификации файлы `.hsjon` автоматически обновятся. Теперь английские файлы будут содержать стандартные записи перевода для нового содержимого. Файлы на других языках будут содержать те же записи, но закомментированные. Для локализации содержимого автору необходимо отредактировать файлы .hjson с нужным текстом, сохранить, скомпилировать и перезагрузить модификацию заново.

## Синтаксис HJSON
Файлы `.hjson` содержат данные в формате Hjson. Hjson похож на JSON, но предназначен для чтения человеком. Подробности синтаксиса Hjson описаны на сайте [Hjson](https://hjson.github.io/), но большинство мододелов могут просто следовать примерам, чтобы разобраться в синтаксисе. 

### Многострочность
Если строка текста требует нескольких строк, используйте следующий синтаксис. Следите за тем, чтобы отступы были одинаковыми:
```
SomeKey: 
	'''
	Данный ключ перевода имеет 2 строки.
	Это 2-я строка!
	'''
```
В качестве альтернативы можно также использовать `\n`, но для удобства чтения это не рекомендуется. Кавычки нужны для того, чтобы `\n` интерпретировался как новая строка. Обратите внимание, что при обновлении файлов `.hjson` tModLoader автоматически преобразует их в приведённый выше синтаксис: 
```
SomeKey: "Данный ключ перевода имеет 5 строк и низкую читабельность.\nЭто 2-я строка!\nЭто 3-я строка!\nЭто 4-я строка!\nЭто 5-я строка!"
```

### Специальные символы
Если значение перевода должно начинаться с `{}[],:` или с пробела, то перевод необходимо заключить в кавычки. В других ситуациях кавычки можно не использовать. Если значение требует точной `"`, можно использовать многострочный синтаксис:
```
ExamplePetBuff: {
	DisplayName: "{$Mods.ExampleMod.Common.PaperAirplane}"
	Description: '''"Пусть этот питомец будет для вас примером!"'''
}
```

### Особенности HJSON tModLoader

#### Цвет

`[c/color:text]` может отображать цветные тексты. 
Значение `color` представляет собой шестнадцатеричный цветовой код. 

Пример: 
```
Yes: "[c/008000:yes]"
No: "[c/FF0000:no]"
```
При этом «да» будет отображаться зелёным цветом, а «нет» - красным.

#### Предметы

`[i:ItemID]` и `[i:ItemClassName]` могут отображать предметы в сообщении.  
`ItemID` - это `type` предмета. Поскольку модицифицированные предметы не имеют фиксированного `type`, вместо него можно использовать `[i:ModName/ItemName]`.  
`ModName` - это имя класса вашей модификации, а `ItemName` - имя класса вашего предмета. 

`[i/pPrefixID:ItemID]` позволяет отобразить предмет с префиксом.  
`PrefixID` - это `type` префикса.  

`[i/sStack:ItemID]` может отображать предмет в определённой таблице ячеек.  
`Stack` - это количество предметов в таблице ячеек. 

Пример: 
```
Label: "[i:ImproveGame/StarburstWand] Пуск супермодели!"
Tooltip: "[i/p57:HiveBackpack] - забавный аксессуар, а [i/s1145:2] - просто грязь."
```
В этом примере `Label` будет отображать `(Значок жезла звёздной вспышки) Пуск супермодели!`, `StarburstWand` - это модифицированный предмет из Качества жизни.  
В `Tooltip` будет отображаться `рюкзак безжалостного улья` и `грязевой блок` в количестве по 1145. 

#### Привязка клавиш

`<KeybindName>` может отображать клавишу, привязанную к клавише.  
`KeybindName` - это имя привязанной клавиши. 

Пример: 
```
Tip: "Нажмите <right>, чтобы использовать специальную атаку"
```
`<right>` будет отображаться как клавиша, привязанная к правой клавише мыши.  

## Комментарии
Файлы `.hjson` могут содержать различные стили комментариев. tModLoader использует комментарии Hjson для передачи двух различных концепций. 

Комментарии, использующие `#` в начале строки, являются собственно комментариями, которые могут использоваться авторами модификаций для напоминания о полезных вещах. Эти комментарии должны располагаться непосредственно над ключом, к которому они относятся. Если не поместить комментарий над элементом, то при автоматическом обновлении файлов локализации в tModLoader он будет потерян или неправильно расположен.

Пример:
```
ExampleCanStackItem: {
	DisplayName: Example CanStack Item: Подарочный мешок
	# Ссылается на языковую клавишу с надписью «Нажмите правую кнопку мыши, чтобы открыть» на языке игры
	Tooltip: "{$CommonItemTooltip.RightClickToOpen}"
}
```

Эти комментарии будут скопированы из англоязычных файлов в другие, где они могут напоминать переводчикам о том, где, например, используются пользовательские ключи перевода.

Комментарии, использующие стиль `/* */` или `//` в начале строки, используются tModLoader для указания на то, что ключ на другом языке перевода ещё не переведён. Это служит индикатором для автора о том, на какие языки не хватает перевода. Переводчик может перевести значение перевода на свой язык и удалить синтаксис комментария. Авторы не должны использовать этот синтаксис для обычных комментариев, так как они будут потеряны при автоматическом обновлении файлов `.hjson` в игре.

## Имена файлов перевода
tModLoader попытается загрузить все файлы `.hsjon` в модификацию как файлы локализации. Как таковые, файлы локализации могут быть размещены в любой папке, но по традиции мы рекомендуем поместить их в папку с именем «Localization» в корне исходной папки вашего мода. Генератор модификаций следует этому соглашению и для начала работы создаст в вашей модификации файл `Localization/en-US.hjson`.

Для определения языка в начале имени файла или в имени содержащей его папки должен присутствовать допустимый код культуры.

### Культура

Поддерживаются следующие языки, также известные как культуры: Английский ("en-US"), немецкий ("de-DE"), итальянский ("it-IT"), французский ("fr-FR"), испанский ("es-ES"), русский ("ru-RU"), китайский ("zh-Hans"), португальский ("pt-BR") или польский ("pl-PL"). Эти коды используются для указания того, к какому языку относится файл `.hjson`. Чтобы начать поддержку нового языка, см. раздел [добавления нового языка](#добавление-нового-языка).

### Префикс
Префикс файла `.hjson` указывает на то, что все записи локализации в этом файле имеют общий префикс. Чаще всего он используется для того, чтобы опустить в файлах локализации записи `Mods` и `ExampleMod`. Если их опустить, то файл становится менее изрезанным и с ним легче работать. Подавляющее большинство модификаций не будет использовать значения локализации вне префикса.

Например, файл с именем `Localization/en-US_Mods.ExampleMod.hjson` унаследует префикс `Mods.ExampleMod`, что означает, что файл может начинаться непосредственно с записи для `Items`.

Для этого используется следующая схема: Путь к файлу разделяется по папкам, затем по символам подчёркивания. После того, как культура найдена, в качестве префикса используется следующий результат. Ниже приведены примеры опций, указывающих на то, что файл предназначен для русского языка и должен использовать префикс `Mods.ExampleMod`.

```
Localization/ru-RU_Mods.ExampleMod.hjson
Localization/ru-RU/Mods.ExampleMod.hjson
ru-RU_Mods.ExampleMod.hjson
ru-RU/Mods.ExampleMod.hjson
Localization/CoolBoss/ru-RU_Mods.ExampleMod.hjson
```

## Множественные файлы
Авторы могут использовать несколько файлов `.hjson` для организации своих переводов. Например, если модификация содержит `en-US_Mods.ExampleMod.Items.hjson` и `en-US_Mods.ExampleMod.hjson`, то файл `en-US_Mods.ExampleMod.Items.hjson` может содержать всю локализацию предметов, а другой файл - остальные записи локализации. Новое содержимое будет автоматически попадать в существующий файл `.hjson`, имеющий записи, наиболее схожие с ключом перевода.

If you split up localization files, you only need to edit the English files and then build and reload the mod. The other languages will automatically adjust themselves to match the same layout.

# Добавление новых ключей перевода
Записи для нового содержимого будут автоматически заполнять файлы `.hjson`, однако в них можно добавлять и свои ключи перевода.

## Добавление ключей вручную
Для добавления своих ключей автор может следовать синтаксису `.hjson` для непосредственного добавления записи локализации. Например, в ExampleMod есть категория «Common», все эти записи были добавлены вручную, поскольку они не используются классами tModLoader напрямую.

Например, начнём с такого файла `.hjson`:
```
Mods: {
	ExampleMod: {
    		Common: {
			PaperAirplane: Бумажный самолётик
		}
        
		Currencies.ExampleCustomCurrency: примерная валюта
   	 }
}
```

Мы можем добавить новую запись для ключа `Mods.ExampleMod.Common.НовыйКлюч`, добавив строку и следуя примеру `PaperAirplane`. Мы можем добавить новую категорию `Uncommon`, следуя синтаксису, показанному в категории `Common`. Мы также можем добавить запись, занимающую всего одну строку, вместо того чтобы указывать категорию отдельно, следуя примеру `Currencies.ExampleCustomCurrency`. Ниже показан каждый из этих подходов:
```
Mods: {
	ExampleMod: {
    		Common: {
			PaperAirplane: Бумажный самолётик
        		HotDog: Хот-дог
		}
        
 		Uncommon: {
            		Helicopter: Примерный вертолёт
       		}
        
		Currencies.ExampleCustomCurrency: примерная валюта
        	Currencies.DirtCurrency: куча грязи
    	}
}
```

Следует иметь в виду, что при автоматическом обновлении файлов локализации tModLoader сам решит, как организовать и отформатировать файл, в результате чего записи будут перемещаться, но данные не будут потеряны.


## Добавление свойств локализации
Авторы могут добавлять свойства `LocalizedText` в свои классы для различных целей. При правильной реализации эти свойства будут автоматически заполнять файлы `.hjson` и будут готовы к работе над локализацией. 

В примере [ExampleHealingPotion.cs](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Content/Items/Consumables/ExampleHealingPotion.cs) показано одно из таких применений. В `ExampleHealingPotion` используется свойство `LocalizedText` под названием `RestoreLifeText`, которое используется в динамической всплывающей подсказке.

Основной подход заключается в следующем:
1. Добавьте статическое свойство `LocalizedText` в свой класс
2. Назначьте это свойство в `SetStaticDefaults` с помощью метода `this.GetLocalization`
3. При необходимости получите значение локализованного текста, обратившись к свойству

Пример:
```cs
public class ExampleHealingPotion : ModItem
{
	// Шаг 1: Создайте статическое свойство LocalizedText
	public static LocalizedText RestoreLifeText { get; private set; }

	public override void SetStaticDefaults() {
		// Шаг 2: Присвоить RestoreLifeText результату GetLocalization
		RestoreLifeText = this.GetLocalization(nameof(RestoreLifeText));
	}

	public override void ModifyTooltips(List<TooltipLine> tooltips) {
		TooltipLine line = tooltips.FirstOrDefault(x => x.Mod == "Terraria" && x.Name == "HealLife");

		if (line != null) {
			// Изменить текст на «Восстанавливает максимум/2 (максимум/4 при быстром лечении) ед. здоровья».
			// Шаг 3: Получение локализованного текста. В данном примере используется метод Format, поскольку в нем есть заполняемые поля, но свойство Value можно использовать и иначе
			line.Text = Language.GetTextValue("CommonItemTooltip.RestoresLife", RestoreLifeText.Format(Main.LocalPlayer.statLifeMax2 / 2, Main.LocalPlayer.statLifeMax2 / 4));
		}
	}
}

```

В приведённом примере файл `.hjson` был автоматически заполнен записью для `RestoreLifeText` наряду с существующими записями `DisplayName` и `Tooltip`. Автор затем обновил его, добавив английский текст:
```
ExampleHealingPotion: {
	DisplayName: Example Healing Potion
	Tooltip: ""
	RestoreLifeText: "{0} ({1} when quick healing)"
}
```

**Примечание**
Экземпляры `LocalizedText` предназначены для статического хранения. В идеале их нужно регистрировать и извлекать один раз во время загрузки. В примере `ExampleHealingPotion` регистрация выполняется в `SetStaticDefaults`, а полученный `LocalizedText` кэшируется в свойстве `RestoreLifeText`. Если кэширование требует слишком больших усилий, то за небольшую плату можно обращаться к свойству каждый раз, когда оно необходимо. Обратите внимание, что для того, чтобы переводы автоматически заполняли файлы `.hjson`, необходимо обращаться к свойству хотя бы один раз во время загрузки.

### Получение текста из локализируемых свойств

В классе свойство `LocalizedText` может быть использовано для отображения локализованного текста пользователю:

```cs
Main.NewText(SomeLocalizedTextProperty.Value);
```

Если в тексте имеются заполнители, то они могут быть заполнены методом `Format`, который принимает столько аргументов, сколько имеется заполнителей:

```cs
Main.NewText(SomeLocalizedTextPropertyWithPlaceholders.Format(Main.LocalPlayer.statLifeMax2, Main.LocalPlayer.statManaMax2));
```

### Наследуемые локализированные свойства
При наследовании вместо статического свойства можно использовать только свойство `get` в базовом классе или нестатическое свойство в наследуемых классах. Природа наследования позволяет повторно использовать логику и перевод, сохраняя код и файлы `.hjson` чистыми и без ненужных повторений.

Например, представим себе базовый класс, общий для нескольких элементов в модификации. В базовый класс может быть добавлено свойство, содержащее `LocalizedText` для каждого наследуемого предмета. Чтобы свойство автоматически появилось в файлах `.hjson`, к нему нужно обратиться во время `SetStaticDefaults`.

**Базовый класс: MyBaseClass** 
```cs
public LocalizedText SpecialMessage => this.GetLocalization(nameof(SpecialMessage));

public override void SetStaticDefaults() {
	_ = SpecialMessage;
}
```

Если классы `ClassA` и `ClassB` наследуют от `MyBaseClass`, то файл `.hjson` будет автоматически заполнен неполными записями для ключа `SpecialMessage`:

```
ClassA: {
	DisplayName: Class A 
	Tooltip: ""
	SpecialMessage: Mods.ExampleMod.Items.ClassA.SpecialMessage
}

ClassB: {
	DisplayName: Class B
	Tooltip: ""
	SpecialMessage: Mods.ExampleMod.Items.ClassB.SpecialMessage
}
```

Если `ClassA` или `ClassB` переопределяют `SetStaticDefaults`, не забудьте сохранить `base.SetStaticDefaults()` для выполнения кода родителя (для доступа к свойству LocalisedText).

Создаваемый `GetLocalization` ключ будет иметь вид `Mods.{НазваниеМода}.{КатегорияЛокализации}.{НазваниеСодержимого}.{suffix}`. Если необходим конкретный ключ, выходящий за рамки ожидаемого шаблона, автор может использовать `Language.GetOrRegister("Полный.Ключ.Здесь");` вместо этого. Обратите внимание, что в силу особенностей конструкции C# `GetLocalization` должен вызываться с префиксом `this.`, его нельзя опускать. Благодаря использованию полного ключа в наследуемом свойстве общая локализация может существовать в одном общем ключе перевода, а наследуемые классы, которым нужен собственный ключ, переопределяют свойство и используют свой ключ через `this.GetLocalization`.

### Другой пример

[ExampleChest.cs](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Content/Tiles/Furniture/ExampleChest.cs) служит примером использования своего ключа. По умолчанию tModLoader регистрирует для каждого `ModTile` единственный ключ трансляции в виде `Mods.{НазваниеМодификации}.Tiles.{НазваниеСодержимого}.MapEntry`. Этот ключ позволяет легко добавить элемент карты к плитке. (Записи карты управляют текстом, отображаемым пользователю при наведении курсора на плитку в полноэкранной карте). Однако для `ExampleChest` требуется 2 записи карты. Используя `GetLocalization`, можно легко добавить новые ключи в файлы локализации:

```cs
AddMapEntry(new Color(200, 200, 200), this.GetLocalization("MapEntry0"), MapChestName);
AddMapEntry(new Color(0, 141, 63), this.GetLocalization("MapEntry1"), MapChestName);
```

В результате работы этого кода файл локализации теперь содержит эти ключи, готовые для локализации на другие языки:
```
ExampleChest: {
	MapEntry0: Example Chest
	MapEntry1: Locked Example Chest
}
```

В других местах файла ExampleChest.cs эти ключи локализации динамически извлекаются с помощью `GetLocalization`:

```cs
public override LocalizedText DefaultContainerName(int frameX, int frameY) {
	int option = frameX / 36; // Используйте frameY, чтобы определить, в каком кадре находится коробка, что соответствует различным состояниям.
	return this.GetLocalization("MapEntry" + option);
}
```

Такой подход удобен для динамических ключей локализации.

### `ModType` и `ILocalizedModType`
Авторы, реализующие пользовательский `ModType`, могут реализовать `ILocalizedModType` для облегчения локализации. Для этого достаточно добавить `, ILocalizedModType` в наследование класса и реализовать свойство `LocalizationCategory`, добавив `public string LocalizationCategory => "ТипКатегорииМоейМодификации";`. Для каждого `LocalizedText` в пользовательском классе `ModType` можно использовать свойство `public virtual LocalizedText DisplayName => this.GetLocalization(nameof(DisplayName), PrettyPrintName);`, что позволит им правильно классифицироваться в файлах `.hjson`, как и другим существующим классам `ModType`.

**Подробнее:** `GetLocalization` - это вспомогательный метод, позволяющий упростить код и избежать опечаток. `GetLocalization` равен вызову `Language.GetOrRegister` с передачей полного ключа. Аналогично, `GetLocalizedValue` равен вызову `Language.GetTextValue`. При желании `GetLocalizationKey` можно использовать для получения созданного ключа.

`GetLocalization` и `Language.GetOrRegister` имеют необязательный второй параметр `makeDefaultValue`, определяющий функцию, которая будет использоваться для создания значения по умолчанию, принимаемого в случае, если локализация не существует. Например, если передать `() => ""`, то значением по умолчанию будет пустая строка, а не ключ. Авторы могут передать `PrettyPrintName`, чтобы добиться типичного поведения: взять внутреннее имя содержимого и добавить пробел между заглавными буквами. Этот подход следует использовать, если локализация является необязательной или для неё есть разумное значение по умолчанию.

# Добавление нового языка
По умолчанию tModLoader будет создавать и обновлять файлы локализации только для языков, уже присутствующих в файлах `.hjson`. Чтобы добавить новый язык, просто создайте текстовый файл и назовите его так же, как и существующие файлы локализации. Необходимо создать только один файл. Путь к файлу или папке должен содержать код языка: Английский ("en-US"), немецкий ("de-DE"), итальянский ("it-IT"), французский ("fr-FR"), испанский ("es-ES"), русский ("ru-RU"), китайский ("zh-Hans"), португальский ("pt-BR") или польский ("pl-PL"). После того как файл создан и имеет правильное расширение, перекомпилируйте модификацию. В файле появятся записи, готовые к переводу. Другие файлы также будут создаваться в соответствии с организацией английских `hjson`-файлов.

Комментарии и организация файлов локализации, отличных от английских, наследуются от английских файлов. Если вы хотите добавить упоминания о переводчиках, добавьте их в комментарий в верхней части англоязычных файлов, и оттуда они будут распространяться на неанглоязычные файлы.

Авторы могут свободно организовывать файлы английской локализации по своему усмотрению, а файлы других языков будут обновляться в соответствии с ними. Если вы разделите файлы локализации, вам нужно будет отредактировать только английские файлы, а затем скомпилировть и перезагрузить модификацию. Остальные языки автоматически подстроятся под него. Удаление ключей из английских файлов аналогичным образом приведёт к удалению ключей из файлов других языков. Короче говоря, авторам, как правило, достаточно поработать с английскими файлами, а остальные языковые файлы будут автоматически подстраиваться под них.

---

```
Note to wiki editors: 
This page is NOT an exact translation of the original page. 
There are additions, deletions or modifications based on nature the target language. 
If you want to translate this page, you are suggested to refer to the original page. 
```

---

````
Translated by Blueberryy (theonlyoneblueberry on Discord). 
````