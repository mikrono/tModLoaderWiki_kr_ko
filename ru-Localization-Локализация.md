***
Данное руководство было написано для tModLoader вер. 1.4.4, будущей версии tModLoader. В текущей версии tModLoader файлы локализации не будут автоматически обновляться, а некоторые методы, упомянутые в данном руководстве, не существуют. Основные концепции остаются в силе.
***

[Original Page (English) | Изначальная страница (на английском)](https://github.com/tModLoader/tModLoader/wiki/Localization)<br />
[中文版 | Версия на китайском](https://github.com/tModLoader/tModLoader/wiki/zh-Localization-%E6%9C%AC%E5%9C%B0%E5%8C%96)

---

# Что представляет собой локализация?
Локализация или перевод обеспечивает возможность использования модификации пользователями, говорящими на языке, отличном от языка, на котором говорит автор. Каждый фрагмент текста, который пользователь может увидеть во время игры в модификацию, содержится в текстовых файлах, называемых файлами локализации. Например, в ExampleMod есть предмет, который на английском языке называется «Paper Airplane», а на русском - «Бумажный самолётик». Благодаря использованию локализации русскоязычные пользователи могут понимать и наслаждаться содержимым ExampleMod, не изучая английский язык.

С этими файлами локализации легко работать, что позволяет переводить модификации пользователям, не имеющим технических навыков. Затем эти переводы могут быть предоставлены автору или опубликованы в виде новой модификации, что позволит большему числу людей насладиться модификацией.

**Даже если вы не собираетесь лично переводить свою модификацию на другие языки, вам необходимо использовать файлы локализации для того языка, который вы поддерживаете.**

На этой вики-странице рассматриваются вопросы локализации, предназначенные для разработчиков модификаций. Если вы хотите перевести существующую модификацию или предоставить локализацию для самого tModLoader, пожалуйста, ознакомьтесь с [(англ.) вики-страницей вклада в локализацию](https://github.com/tModLoader/tModLoader/wiki/Contributing-Localization).

# Переход с версии 1.4.3 на 1.4.4
Начиная с версии tModLoader 2023.01, все локализации теперь полностью выполняются в файлах `.hjson`. Объявление переводов в коде больше не поддерживается. Это изменение значительно упростит управление локализацией и облегчит создание переводов модификаций. Если вас интересует более подробное обоснование этих изменений, см. [(англ.) предложение по основным изменениям локализации](https://github.com/tModLoader/tModLoader/issues/3074)

**Если вы не используете Git или какую-либо форму контроля версий, то перед продолжением работы рекомендуется сделать резервную копию папки с исходным кодом вашей модификации.**

## Генерация файлов локализации в версии 1.4.3
Для начала нам необходимо использовать старый tModLoader для экспорта файлов локализации. Для перехода на ветку `«Нет»` необходимо использовать Steam. ([(англ.) Инструкция по переключению между версиями tModLoader](https://github.com/tModLoader/tModLoader/wiki/Basic-tModLoader-Usage-FAQ#switch-to-stable-tmodloader-or-to-preview-tmodloader))

После установки нужной версии игры откройте tModLoader, включите модификацию и откройте меню `«Исходники модов»`. Найдите в списке свою модификацию. При наведении на неё вы увидите зелёную стрелку с надписью «Export 1.4.4+ localization files», нажмите её.    
![image](https://user-images.githubusercontent.com/4522492/210681409-a659670d-5908-4e5d-bd45-74c0545f4666.png)    
Теперь перейдите в папку `«ModSources»` и найдите файлы локализации вашей модификации. Если ранее у вас не было файлов локализации, перейдите на верхний уровень папки вашей модификации. Вы должны увидеть только что созданные файлы `.hjson.new`:    
![image](https://user-images.githubusercontent.com/4522492/210681629-8aad2234-bd56-40c8-b03f-7e36b98d4486.png)    
Откройте новые файлы в текстовом редакторе и убедитесь, что они выглядят правильно. В них должны присутствовать все записи, которые ранее были в текущих файлах `.hjson`, а также вновь созданные записи для всего остального содержимого модификации. Если всё выглядит правильно, переходите к следующим шагам.

### Изменённые ключи
Обратите внимание, что многие шаблоны клавиш изменились. Они будут автоматически скорректированы при экспорте, но все пользовательские ключи или код, использующий старый шаблон ключей, придётся исправлять вручную. Например, `Mods.{НазваниеМодификации}.ItemName.{НазваниеСодержимого}` теперь `Mods.{НазваниеМодификации}.Items.{НазваниеСодержимого}.DisplayName`.

<details><summary>Шаблоны изменённых ключей</summary>

```
Mods.{НазваниеМодификации}.DamageClassName.{НазваниеСодержимого}	-->	Mods.{НазваниеМодификации}.DamageClasses.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.InfoDisplayName.{НазваниеСодержимого}	-->	Mods.{НазваниеМодификации}.InfoDisplays.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.BiomeName.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Biomes.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.BuffName.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Buffs.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.BuffDescription.{НазваниеСодержимого}	-->	Mods.{НазваниеМодификации}.Buffs.{НазваниеСодержимого}.Description
Mods.{НазваниеМодификации}.ItemName.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Items.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.ItemTooltip.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Items.{НазваниеСодержимого}.Tooltip
Mods.{НазваниеМодификации}.NPCName.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.NPCs.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.Prefix.{НазваниеСодержимого}			-->	Mods.{НазваниеМодификации}.Prefixes.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.ProjectileName.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Projectiles.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.ResourceDisplaySet.{НазваниеСодержимого}	-->	Mods.{НазваниеМодификации}.ResourceDisplaySets.{НазваниеСодержимого}.DisplayName
Mods.{НазваниеМодификации}.Containers.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Tiles.{НазваниеСодержимого}.ContainerName
Mods.{НазваниеМодификации}.MapObject.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Tiles.{НазваниеСодержимого}.MapEntry
Mods.{НазваниеМодификации}.Keybind.{НазваниеСодержимого}		-->	Mods.{НазваниеМодификации}.Keybinds.{НазваниеСодержимого}.DisplayName
```

</details>

## Переход на версию 1.4.4 tModLoader и компилирование модификации
Используйте Steam для перехода на ветку `1.4.4-preview`. ([(англ.) Инструкции по переключению между версиями tModLoader](https://github.com/tModLoader/tModLoader/wiki/Basic-tModLoader-Usage-FAQ#switch-to-stable-tmodloader-or-to-preview-tmodloader))

После запуска tModLoader вы заметите, что ваш мод (и, скорее всего, все остальные включенные вами модификации) не загружается, что вполне ожидаемо. Зайдите в меню «Исходники модов» и нажмите кнопку «Запустить tModPorter». Наряду с другими изменениями, это удалит весь код, использующий старый подход к локализации.     
![image](https://user-images.githubusercontent.com/4522492/210683375-43816104-2812-4db2-bac6-813ebb47a089.png)    
После этого необходимо найти эти файлы `.hjson.new` и использовать их для замены существующих файлов `.hjson`. Для этого сначала удалите текущие файлы `.hjson` (если таковые имеются), а затем переименуйте файлы `.hjson.new` в расширение `.hjson`. (Если вы не можете переименовать расширения файлов, то вам необходимо [включить отображение «Расширения имён файлов»](https://gfycat.com/TheseSameGrasshopper) в системе, чтобы вы могли это сделать.)

Теперь, возможно, потребуется открыть Visual Studio и исправить все оставшиеся проблемы компиляции. После исправления оставшихся проблем можно перекомпилировать модификацию, и она должна заработать. После того как всё заработает, можно найти в исходном коде модификации строки типа `// Tooltip.SetDefault("Это модифицированный предмет.");` или `// DisplayName.SetDefault("Пример меча");` и удалить их. Они больше не будут использоваться. (Чтобы легко найти большинство этих строк, можно выполнить поиск по всем файлам проекта по поисковому запросу `.SetDefault(`)

Для облегчения поиска вызовов (и замены их на пустую строку) можно использовать следующие регулярные выражения. Оба варианта требуют использования такого инструмента, как Notepad++, с включённой опцией «. - новая строка»
- Однострочные комментарии: `\s+// [\w.]+SetDefault\(".+?;`
- Многострочные комментарии: `\s+/\*[\s\w.]+SetDefault\(".+?\*/`

Краткое руководство по Notepad++, чтобы применить это ко всему моду: Откройте любой файл в Notepad++, нажмите ctrl + F, перейдите на вкладку «Найти в файлах», выберите «Регуляр. выражен.» и «. - новая строка» внизу, затем в «Фильтры:» добавьте `*.cs`, для «Папка:» нажмите кнопку справа, чтобы перейти к корневой папке вашей модификации. Наконец, вставьте регулярное выражение в «Найти:» и оставьте «Заменить на:» пустым, затем нажмите «Заменить в файлах». Если вы допустили ошибку, просто нажмите ctrl + Z один раз, чтобы вернуть все изменения. Рекомендуется использовать программы версионирования, такие как git, чтобы иметь возможность вручную вернуть изменения, если это необходимо, и просмотреть результат.

# Процесс локализации
Обновление файлов локализации происходит в конце загрузки модификации. Это означает, что автору необходимо скомпилировать и загрузить модификацию после добавления контента, чтобы файлы локализации обновились. После обновления автор может отредактировать файлы `.hjson` и добавить переводы. После этого мод можно скомпилировать и снова загрузить, чтобы переводы появились в игре.

Во избежание потери работы, пожалуйста, помните о предполагаемом рабочем процессе:

1. Добавьте новое содержимое в модификацию, например, нового `ModItem`
2. Скомпилируйте и перезапустите модификацию
3. К этому моменту файлы `.hjson` будут автоматически обновлены записями для нового содержимого. Отредактируйте файлы `.hjson`, чтобы дать новому содержимому имя на английском
4. Скомпилируйте и перезапустите модификацию
5. Файлы `.hjson` на других языках, кроме английского теперь обновляются с помощью соответствующих заполнителей и могут быть также обновлены переводчиками или создателями модификаций

Если переводчик присылает вам обновлённый файл `.hjson` для непосредственного добавления в модификацию, имейте в виду, что она может быть перезаписана, если модификация загрузится и tModLoader по какой-то причине обнаружит, что файл `.tmod` новее файла `.hjson`. В этом случае лучшим вариантом будет компилирование модификации перед его загрузкой или перезагрузкой. Можно выполнить компилирование в Visual Studio при закрытом tModLoader, а можно пропустить загрузку мода при запуске tModLoader, удерживая клавишу shift, и сразу перейти в меню «Исходники модов» для компилирования модификации. Если вы забыли это сделать и обнаружили, что tModLoader вернул только что переведённые файлы `.hjson` к их старому содержимому, скопируйте обновлённые файлы `.hjson` в папку с исходниками ещё раз, а затем выполните компиляцию и перезагрузку.

## Обновление в реальном времени
tModLoader определяет момент сохранения файлов `.hjson` в папках ModSources и автоматически перезагружает их во время игры. При таком подходе автору не нужно перекомпилировать и перезагружать модификацию для проверки новых значений. Если вы используете эту возможность, не забудьте перекомпилировать модификацию перед публикацией, чтобы все изменения попали в опубликованную версию.

Здесь мы видим эту функцию в действии. Автор редактирует файл `en-US.hjson`, а затем сохраняет его, чтобы изменить английское название и всплывающую подсказку предмета `ExampleWings`. Изменения появляются в игре через пару секунд:    

https://user-images.githubusercontent.com/4522492/229942438-26604fd7-9073-436c-b2ab-d99b4f2efeb7.mp4

# Принцип работы локализации
Каждый фрагмент текста в игре, от названий предметов до слов в главном меню, использует локализацию. Каждый фрагмент текста в игре фактически представляет собой пару данных: ключ локализации и значение локализации. Например, когда игрок создаёт маленький мир, игра использует ключ локализации `UI.WorldSizeSmall` для поиска правильного значения перевода для текущего загруженного языка и выводит пользователю слово «Small», если выбран английский язык. Если выбран другой язык, игра всё равно обращается к `UI.WorldSizeSmall`, но значение локализации будет другим. Поскольку создатели Terraria пишут код на английском языке, большинство ключей локализации очень похожи на их английское значение.

В tModLoader модификации используют файлы `.hjson` для чистого хранения ключей локализации и значений локализации. Каждый язык имеет свой собственный файл `.hjson`. Если вы знакомы с JSON, то эти файлы `.hjson` будут вам знакомы. 

Вот простой пример:

Имя файла: **tModLoader/ModSources/ExampleMod/ru-RU.hjson**
```
Mods: {
	ExampleMod: {
		Items: {
			ExampleItem: {
				DisplayName: Примерный предмет
				Tooltip: Это модифицированный предмет.
			}
		}
	}
}
```

В данном примере мы видим два основных понятия: ключи локализации и переводы локализации. Ключ локализации образуется из комбинации всех текстов, расположенных слева от `:` на каждом уровне вложенности. Текст, расположенный справа от `:`, является значением локализации. В данном примере передаются 2 ключа локализации и соответствующие им значения локализации: `Mods.ExampleMod.Items.ExampleItem.Displayname` соответствует `«Примерный предмет»` и `Mods.ExampleMod.Items.ExampleItem.Tooltip` соответствует `«Это модифицированный предмет.»`. Если синтаксис кажется сложным, не волнуйтесь, авторам не нужно вручную редактировать эти файлы, игра будет обновлять их автоматически.

При загрузке этой модификации tModLoader найдёт все файлы локализации, соответствующие текущему языку, и сохранит их в памяти. Когда игре необходимо вывести текст на экран, используется ключ, который запрашивает сохранённые данные и извлекает нужный текст. Переводы хранятся в памяти в виде объекта `LocalizedText`, авторы могут использовать метод `Language.GetText` для получения объекта `LocalizedText` из ключа локализации. Свойство `Value` может быть использовано для получения значения локализации из объекта `LocalizedText`. В качестве альтернативы метод `Language.GetTextValue` возвращает значение локализации непосредственно из ключа локализации:

```cs
string hivePackDialogue = Language.GetTextValue("Mods.ExampleMod.Dialogue.ExampleTravelingMerchant.HiveBackpackDialogue"); // Непосредственно возвращает текст для отображения, string
или
string hivePackDialogue = Language.GetText("Mods.ExampleMod.Dialogue.ExampleTravelingMerchant.HiveBackpackDialogue").Value; // Возвращает LocalizedText, для получения string использует его свойство Value.
или
LocalizedText hivePackDialogueLocalizedText = Language.GetText("Mods.ExampleMod.Dialogue.ExampleTravelingMerchant.HiveBackpackDialogue"); // Возвращает LocalizedText
string hivePackDialogue = hivePackDialogueLocalizedText.Value; // Присваивает Value вновь объявленной string.
```

## Ключи локализации
tModLoader автоматически назначает ключи перевода для большинства содержимого. Шаблон ключа - `Mods.{НазваниеМодификации}.{Категория}.{НазваниеСодержимого}.{НазваниеДанных}`, где `«НазваниеМодификации»` - внутреннее имя модификации, `«Категория»` определяется типом содержимого, `«НазваниеСодержимого»` - внутреннее имя содержимого (обычно имя класса), а `«НазваниеДанных»` определяет ключ внутри класса. 

Например, `ModItem` имеет `категорию`, установленную на `Items`. Он также имеет 2 отдельных элемента данных, `DisplayName` и `Tooltip`. Если модификация с именем `ExampleMod` добавляет класс `ModItem` с именем `ExampleItem`, то будут созданы и добавлены в файлы `.hjson` два ключа: `Mods.ExampleMod.Items.ExampleItem.DisplayName` и `Mods.ExampleMod.Items.ExampleItem.Tooltip`.

## Заменители
Если в файлах локализации есть текст, который часто повторяется, или если вы хотите использовать существующий текст в игре, то для поддержания чистоты и порядка в файлах локализации можно использовать замены. Замены имеют форму `{$КлючТут}` в значениях локализации. При загрузке игры эти разделы будут заменены локализованным текстом, соответствующим указанному ключу.

Например, в игре уже есть перевод текста `«Нажмите правую клавишу мыши, чтобы открыть»`, хранящийся в ключе `CommonItemTooltip.RightClickToOpen`. Модификация может использовать заменители для повторного использования этого значения. Запись `Tooltip: "{$CommonItemTooltip.RightClickToOpen}"` будет содержать текст `«Нажмите правую клавишу мыши, чтобы открыть»` на языке пользователя этого предмета. Другие существующие переводы, такие как названия элементов и другие общие всплывающие подсказки, также доступны для использования.

Также можно использовать переводы из самого мода. Например, в [(англ.) файлах локализации ExampleMod](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Localization/en-US.hjson), `MapObject.ExamplePylonTile: "{$Mods.ExampleMod.ItemName.ExamplePylonItem}"` используется для повторного использования переводов, содержащихся в ключе `Mods.ExampleMod.ItemName.ExamplePylonItem`.

Многие заменители содержат `{0}` или `{1}`, которые являются заполнителями для значений, которые могут предоставить авторы. Эта функция описана в разделе [«Форматирования строк»](#Форматирование-строк).

### Всплывающие подсказки существующих предметов (Tooltip)
Использование существующих подсказок, предоставляемых игрой, в предметах модификации - хорошая идея. Использование единого языка и существующих переводов делает вашу модификацию более привлекательной для большего количества людей. Разверните раздел ниже, чтобы просмотреть список существующих общих подсказок. Помните, что ключ для всех этих подсказок начинается с `CommonItemTooltip.`. 

<details><summary>Ключи CommonItemTooltip</summary>

```
// Добавлено разработчиками Terraria
"UsesLife": "Использует {0} ед. здоровья",
"UsesMana": "Использует {0} ед. маны",
"RestoresLife": "Восстанавливает {0} ед. здоровья",
"RestoresLifeRange": "Восстанавливает жизнь на {0}-{1}",
"RestoresMana": "Восстанавливает {0} ед. маны",
"MinuteDuration": "Длительность {0} мин.",
"SecondDuration": "Длительность {0} с",
"PlaceableOnXmasTree": "Надевается на новогоднюю ель",
"String": "Увеличивает дистанцию действия йо-йо",
"Counterweight": "Бросает противовес после попадания йо-йо по врагу",
"BannerBonus": "Игроки поблизости получают бонус против: ",
"BannerBonusReduced": "Игроки поблизости получают небольшой бонус против: ",
"SpecialCrafting": "Используется для создания особых предметов",
"DevItem": "Отлично подходит, чтобы впечатлить разработчиков!",
"FlightAndSlowfall": "Позволяет летать и замедляет падение",
"PressDownToHover": "Нажмите ВНИЗ, чтобы включить парение\nНажмите ВВЕРХ, чтобы отключить парение",
"PressUpToBooster": "Удерживайте ВВЕРХ, чтобы ускориться еще больше!",
"RightClickToOpen": "Нажмите <right>, чтобы открыть",
"RightClickToClose": "Нажмите <right>, чтобы закрыть",
"MinorStats": "Немного повышает все характеристики",
"MediumStats": "Умеренно повышает все характеристики",
"MajorStats": "Сильно повышает все характеристики",
"TipsyStats": "Небольшое увеличение параметров ближнего боя и сниженная защита",
"EtherianManaCost10": "Стоит 10 единиц Этерианской маны за каждое использование в борьбе с Этерианским кристаллом",
"GolfBall": "Можно ударить клюшкой для гольфа",
"Sentry": "Призывает часового",
"GolfIron": "Закругленная клюшка, идеальная для ударов на средние дистанции\nМячи для гольфа летят на хорошее расстояние с приличным подъемом",
"GolfPutter": "Специальная клюшка для последних лунок\nМячи для гольфа летят на короткие дистанции и остаются близко к земле для точных ударов",
"GolfWedge": "Специальная клюшка для бункеров с песком или высоких препятствий\nМячи для гольфа очень сильно поднимаются вверх, но летят недалеко",
"GolfDriver": "Прочная клюшка для ударов на дальние дистанции\nМячи для гольфа летят очень далеко с небольшим подъемом",
"Kite": "Змеев можно запускать в ветреные дни\nСматывайте веревку с помощью <right>",
"LavaFishing": "Позволяет ловить рыбу в лаве",
"CreativeSacrificeNeeded": "Исследуйте еще {0}, чтобы разблокировать дублирование",
"CreativeSacrificeComplete": "Дублирование разблокировано",
"TeleportationPylon": "Телепортируйтесь к другому столбу, когда 2 поселенца будут рядом\nВы можете поставить только один столб в каждом биоме",
"Whips": "Ваши призванные существа будут стараться атаковать врагов",
"WizardHatDuringAnniversary": "Увеличивает ваше максимальное количество питомцев на 1",
"MechSummonDuringEverything": "«Часть комплекта»",
"MechdusaSummonNotDuringEverything": "«Не действует в этом мире»",
"LuminiteVariant": "«Запрещенный строительный материал из загробного мира»"

// Добавлено разработчиками tModLoader
"IncreasesMaxLifeBy": "Увеличивает максимальный уровень здоровья на {0} ед.",
"IncreasesMaxManaBy": "Увеличивает максимальный уровень маны на {0} ед.",
"IncreasesMaxLifeByPercent": "Увеличивает максимальный уровень здоровья на {0} %",
"IncreasesMaxManaByPercent": "Увеличивает максимум уровень маны на {0} %",

"IncreasesBowDamageByPercent": "Увеличивает урон от стрел на {0} %",
"IncreasesGunDamageByPercent": "Увеличивает урон от пушек на {0} %",
"IncreasesSpecialistDamageByPercent": "Увеличивает урон от особого дальнобойного оружия на {0} %",

"IncreasesWhipRangeByPercent": "Увеличивает дальность удара кнутом на {0} %",
"IncreasesMaxMinionsBy": "Увеличивает максимальное число ваших прислужников на {0}",
"IncreasesMaxSentriesBy": "Увеличивает урон призываемых существ на {0}",

"IncreasesFishingPowerBy": "Увеличивает мастерство рыбалки на {0}",

"PermanentlyIncreasesMaxLifeBy": "Навсегда увеличивает максимальный уровень здоровья на {0} ед.",
"PermanentlyIncreasesMaxManaBy": "Навсегда увеличивает максимальный уровень маны на {0} ед.",

"ReducesDamageTakenByPercent": "Получаемый урон снижен на {0} %",

"PercentChanceToSaveAmmo": "Шанс {0} % сохранить боеприпасы",
"PercentReducedManaCost": "Уменьшает стоимость в мане на {0} %",

"PercentIncreasedMiningSpeed": "Увеличивает скорость добычи на {0} %",
"PercentIncreasedMovementSpeed": "Увеличивает скорость движения на {0} %",

"ArmorPenetration": "{0} пробивания брони",
"PercentIncreasedDamage": "Увеличивает урон на {0} %",
"PercentIncreasedCritChance": "Увеличивает шанс критического удара на {0} %",
"PercentIncreasedDamageCritChance": "Увеличивает на {0} % урон и шанс критического удара",

"PercentIncreasedMagicDamage": "Увеличивает магический урон на {0} %",
"PercentIncreasedMagicCritChance": "Увеличивает шанс критического магического урона на {0} %",
"PercentIncreasedMagicDamageCritChance": "Увеличивает на {0} % магический урон и шанс критического удара",

"PercentIncreasedMeleeDamage": "Увеличивает урон в ближнем бою на {0} %",
"PercentIncreasedMeleeCritChance": "Увеличивает шанс критического урона в ближнем бою на {0} %",
"PercentIncreasedMeleeDamageCritChance": "Увеличивает на {0} % урон в ближнем бою и шанс критического удара",
"PercentIncreasedMeleeSpeed": "Увеличивает скорость ближнего боя на {0} %",

"PercentIncreasedRangedDamage": "Увеличивает дистанционный урон на {0} %",
"PercentIncreasedRangedCritChance": "Увеличивает шанс критического дистанционного урона на {0} %",
"PercentIncreasedRangedDamageCritChance": "Увеличивает на {0} % дистанционный урон и шанс критического удара",

"PercentIncreasedSummonDamage": "Увеличивает урон призываемых существ на {0} %",
"SummonTagDamage": "Увеличивает урон призываемых существ на {0} ед.",
"PercentSummonTagCritChance": "Увеличивает шанс критического удара призываемых существ на {0} %"
```

</details>

### Прочие существующие переводы

Помимо ключей перевода `CommonItemTooltip.`, предназначенных для подсказок предметов, авторы могут ссылаться на любые другие ключи перевода в игре. Например, `NPCName.BlueSlime` - это ключ, позволяющий получить локализованное имя синего слизня. Авторы могут просмотреть все ключи локализации, скачав файл `.CSV`, упомянутый в разделе [(англ.) руководства Мастерской по расширенных языковым пакетам Terraria](https://forums.terraria.org/index.php?threads/the-ultimate-guide-to-content-creation-and-use-for-the-terraria-workshop.100652/#advancedlanguagepack). 

Обратите внимание, что ключи перевода модификаций не соответствуют шаблону ключей, используемых в Terraria. Например, ключ перевода `PartyZombie` в ExampleMod имеет значение `Mods.ExampleMod.NPCs.PartyZombie.DisplayName`. Ключ перевода содержимого мода не обязательно будет следовать шаблону по умолчанию, поэтому не следует писать код с таким допущением.

### Упрощение области видимости

Если заменяющие ключи имеют общую область видимости со значением ключа локализации, в котором они используются, то заменяющий ключ может быть упрощён. Например, в [(англ.) файлах локализации ExampleMod](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Localization/en-US.hjson) значение ключа `Mods.ExampleMod.ExamplePetItem.DisplayName` установлено в `"{$Common.PaperAirplane}"`. В этом случае игра знает, что нужно проверить наличие ключей в текущей области видимости, в результате чего значение ключа `Mods.ExampleMod.Common.PaperAirplane` будет найдено и подставлено. Используя эту технику, можно, например, опустить `Mods.ModName` из ключей замены.

### Переопределение ключей локализации содержимого
Если многие элементы модификации имеют общий перевод, можно сделать так, чтобы все они указывали на один и тот же ключ перевода. Для этого переопределите свойство и верните результат `Language.GetText`, используя тот ключ перевода, который вы хотите использовать:
```cs
public override LocalizedText Tooltip => Language.GetOrRegister("Mods.ExampleMod.Common.SomeSharedTooltip"); // Переопределяет свойство Tooltip класса в нужный вам LocalizedText.
```
Если вы используете наследование, вам нужно сделать это только в базовом классе и даже можете переопределить это в дочерних классах, если определённый дочерний класс нуждается в другой локализации. О том, как добавить дополнительные локализации к содержимому, помимо свойств по умолчанию, предоставляемых tModLoader, читайте в разделе [«Добавление локализуемых свойств»](#добавление-локализуемых-свойств).

Авторы могут использовать `public override LocalizedText Tooltip => LocalizedText.Empty;`, чтобы указать, что ключ перевода не должен создаваться. Это позволяет сделать файлы локализации чище.

## Форматирование строк
Авторы могут использовать [форматирование строк](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.format?view=net-7.0#insert-a-string), чтобы оставлять в переводах места для заполнения текстом при использовании. Это обычная особенность языка программирования c#. Авторы могут использовать метод `string.Format` или перегрузки `Language.GetTextValue` для использования форматирования строк. Более подробная информация об этом содержится в [(англ.) разделе Placeholders](https://github.com/tModLoader/tModLoader/wiki/Contributing-Localization#placeholders). 

### Привязка значений к локализациям
Во многих элементах перевода присутствуют заполнители типа `{0}` или `{1}`, указывающие на места, где автор может указать значение. Например, ключ перевода `CommonItemTooltips.IncreasesMaxMinionsBy` имеет значение `«Увеличивает максимальное число ваших прислужников на {0}»`. Для того чтобы использовать это значение в предмете аксессуара, необходимо указать число, которое будет использоваться вместо `{0}`.

Во-первых, в файле `.hjson` мы назначаем всплывающую подсказку для нашего элемента:
```
ExampleMinionBoostAccessory: {
	DisplayName: Усилитель прислужников
	Tooltip: "{$CommonItemTooltip.IncreasesMaxMinionsBy}"
}
```

Далее нам необходимо «привязать» к этой подсказке наше предполагаемое значение. Этот аксессуар должен увеличивать максимальное количество прислужников на 3. Для этого мы переопределим свойство `Tooltip` и вызовем метод `WithFormatArgs` на исходной подсказке. Это позволит заполнить заполнитель указанным значением. Мы рекомендуем использовать в классе поле `static int` для хранения этих статистических данных. В приведённом ниже примере `MaxMinionIncrease` используется в двух разных местах. Использование поля позволяет автору одновременно изменять поведение и всплывающую подсказку. Такой подход позволяет избежать опечаток, которые могут привести к рассинхронизации подсказки и поведения.

```cs
public class ExampleMinionBoostAccessory : ModItem
{
	public static int MaxMinionIncrease = 3; // Хранить значения в статическом поле

	public override LocalizedText Tooltip => base.Tooltip.WithFormatArgs(MaxMinionIncrease); // Переписать Tooltip и передать значение

	public override void UpdateEquip(Player player) {
		player.maxMinions += MaxMinionIncrease; // Увеличить количество прислужников, которых может иметь игрок, на три
	}
	
	// другой код...
}
```
### Многочисленные форматируемые заменители
Когда локализация ссылается на несколько заменителей, может возникнуть проблема повторяющихся заполнителей. Например, аксессуар, использующий `CommonItemTooltip.IncreasesMaxManaBy` и `CommonItemTooltip.IncreasesMaxMinionsBy`, обнаружит, что они оба используют заполнитель `{0}`. Попытка привязать значения к всплывающей подсказке, использующей обе эти текстовые заменители, не будет работать без дополнительной работы. Авторы могут использовать специальный синтаксис для смещения индексов в пределах определённого ключа заменителя. Добавление символа `@`, за которым следует число, после ключа-заменителя увеличивает количество мест в этом ключе на указанное число. Вкратце, синтаксис выглядит так: `{$KeyHere@OffsetNumberHere}`. В качестве наглядного примера этой возможности можно привести пример [ExampleBreastplate.cs](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Content/Items/Armor/ExampleBreastplate.cs):

**Существующие записи CommonItemTooltip**
```
"CommonItemTooltip": {
	"IncreasesMaxManaBy": "Increases maximum mana by {0}",
	"IncreasesMaxMinionsBy": "Increases your max number of minions by {0}",
	// и так далее
```

**ExampleMod/Localization/en-US.hjson**
```
ExampleBreastplate: {
	DisplayName: Example Breastplate
	Tooltip:
		'''
		This is a modded body armor.
		Immunity to 'On Fire!'
		{$CommonItemTooltip.IncreasesMaxManaBy}
		{$CommonItemTooltip.IncreasesMaxMinionsBy@1}
		'''
}
```

**ExampleMod/Content/Items/Armor/ExampleBreastplate.cs**
```cs
public class ExampleBreastplate : ModItem
{
	public static int MaxManaIncrease = 20;
	public static int MaxMinionIncrease = 1;

	public override LocalizedText Tooltip => base.Tooltip.WithFormatArgs(MaxManaIncrease, MaxMinionIncrease);

	public override void UpdateEquip(Player player) {
		player.buffImmune[BuffID.OnFire] = true; // Делает игрока невосприимчивым к огню!
		player.statManaMax2 += MaxManaIncrease; // Увеличение количества единиц маны на 20
		player.maxMinions += MaxMinionIncrease; // Увеличение количества прислужников, которых может иметь игрок, на один
	}
}
```
Из этого примера видно, что `Tooltip.WithFormatArgs(MaxManaIncrease, MaxMinionIncrease)` пытается привязать `MaxManaIncrease` к `{0}`, а `MaxMinionIncrease` к `{1}`. Поскольку в записи локализации к `{$CommonItemTooltip.IncreasesMaxMinionsBy@1}` было добавлено `@1`, исходное значение `{0}` было интерпретировано как `{1}`, что позволило игре привязать значение `MaxMinionIncrease` к нужному месту в тексте всплывающей подсказки.

Это может показаться несколько сложным, проще вообще игнорировать заменитель текста и `WithFormatArgs` и просто набирать текст подсказки непосредственно в файле локализации, но преимущества такого подхода могут быть значительными при правильном использовании. При таком подходе большая часть вашего мода будет автоматически локализована на другие языки. Кроме того, такой подход значительно снижает вероятность того, что опечатка приведёт к путанице в дальнейшем.

Ещё более сложный пример использования этой функции см. в [ExampleStatBonusAccessory.cs](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Content/Items/Accessories/ExampleStatBonusAccessory.cs) и соответствующей записи [en-US.hjson](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Localization/en-US.hjson#L160).

### Комбинирование переводов для динамического содержимого
В редких ситуациях может потребоваться перевод, в котором упоминается название содержимого другой модификации, но создать конкретный перевод невозможно, поскольку комбинации создаются во время выполнения.

**СОВЕТ:** 
> Избегайте соблазна создавать комбинированные переводы только потому, что английский язык всегда следует определённому шаблону, поскольку не во всех языках может существовать подходящий шаблон. Вместо этого постарайтесь сделать как можно больше уникальных и подробных переводов. Например, может возникнуть соблазн сделать `Mini-{0}` и подставить названия классов урона (`Sentry`) и т.д. Это сработает в английском языке, но в других языках может потребоваться изменение структуры фразы или добавление дополнительной грамматики, основанной на заменителе. Например, `Mini-Sentry` может переводиться как `«Мини-часовой»`, но слово часовой будет с заглавной буквы.

Классическим примером может служить модификация, автоматически добавляющая бесконечные патроны к каждому элементу боекомплекта в игре. `WithFormatArgs` может принимать в качестве параметров другие `LocalizedText`. Вы также можете переопределить свойство `LocalizedText`, чтобы вернуть совершенно другой `LocalizedText` (см. `Tooltip` в примере ниже)
```
InfiniteAmmoItem.DisplayName: "Infinite {0}"
```

```cs
public class InfiniteAmmoItem : ModItem
{
    Item baseAmmoItem;
    
    public override LocalizedText DisplayName => base.DisplayName.WithFormatArgs(baseAmmoItem.DisplayName);

    public override LocalizedText Tooltip => baseAmmoItem.Tooltip;
}
```

### Использование ModConfig
Атрибуты `Label` и `Tooltip`, используемые в элементах `ModConfig`, могут быть снабжены текстовыми заменителями аналогичным образом. Через атрибуты `LabelArgs` и `TooltipArgs` можно передавать значения соответствующему переводу. Обратите внимание, что строки, начинающиеся с «$», интерпретируются как ключи перевода. Эту возможность демонстрируют примеры `InterpolatedTextA`, `InterpolatedTextB` и `InterpolatedTextC` в [ModConfigShowcaseLabels.cs](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Common/Configs/ModConfigShowcases/ModConfigShowcaseLabels.cs).

## Множественное число
При использовании заполнителей для чисел, например, в `{0} minutes ago`, в английском языке возникают проблемы, когда число равно 1. Если число равно 1, то в тексте должно быть написано «1 minute ago», а не «1 minutes ago». Эта проблема может быть решена с помощью множественного числа. Более подробная информация об этой возможности содержится в [(англ.) разделе Plurals](https://github.com/tModLoader/tModLoader/wiki/Contributing-Localization#plurals). 

## Метки чата (Chat tag)
Значки цветов и элементов могут быть добавлены к значениям локализации с помощью [(англ.) меток чата Tags](https://terraria.wiki.gg/wiki/Chat#Tags). В качестве примера можно привести `ExampleTooltipsItem` в [(англ.) файлах локализации ExampleMod](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Localization/en-US.hjson).

# Автоматические файлы локализации
tModLoader будет автоматически обновлять файлы `.hjson` при появлении нового содержимого или ключей перевода. Английские файлы будут использоваться в качестве шаблона для других языков, которые будут автоматически наследовать комментарии и оформление. 

Обратите внимание, что файлы локализации будут обновляться только в тех случаях, когда игра сочтёт это целесообразным, для повышения эффективности. Например, модификация должна существовать в папке `ModSources`. Загружаемая модификация также должна быть локально скомпилированной. Файлы локализации будут обновляться только в том случае, если временная метка изменения файла старше, чем сама модификация или все модификации, на которые ссылается модификация. Помните, что прямое тестирование старого файла `.tmod` может привести к перезаписи файлов `.hjson` старым содержимым, поэтому рекомендуется использовать Git или создавать резервные копии исходного кода модификации, чтобы можно было восстановить файлы. 

## Добавление содержимого
Когда автор добавляет в свою модификацию новое содержимое, например, `ModItem`, это содержимое изначально не будет локализовано. Автор должен скомпилировать и перезагрузить свою модификацию. После загрузки модификации файлы `.hsjon` автоматически обновятся. Теперь английские файлы будут содержать стандартные записи перевода для нового содержимого. Файлы на других языках будут содержать те же записи, но закомментированные. Для локализации содержимого автору необходимо отредактировать файлы .hjson с нужным текстом, сохранить, скомпилировать и перезагрузить модификацию заново.

## Синтаксис HJSON
Файлы `.hjson` содержат данные в формате Hjson. Hjson похож на JSON, но предназначен для чтения человеком. Подробности синтаксиса Hjson описаны на сайте [Hjson](https://hjson.github.io/), но большинство мододелов могут просто следовать примерам, чтобы разобраться в синтаксисе. 

### Многострочность
Если строка текста требует нескольких строк, используйте следующий синтаксис. Следите за тем, чтобы отступы были одинаковыми:
```
SomeKey: 
	'''
	Данный ключ перевода имеет 2 строки.
	Это 2-я строка!
	'''
```
В качестве альтернативы можно также использовать `\n`, но для удобства чтения это не рекомендуется. Кавычки нужны для того, чтобы `\n` интерпретировался как новая строка. Обратите внимание, что при обновлении файлов `.hjson` tModLoader автоматически преобразует их в приведённый выше синтаксис: 
```
SomeKey: "Данный ключ перевода имеет 5 строк и низкую читабельность.\nЭто 2-я строка!\nЭто 3-я строка!\nЭто 4-я строка!\nЭто 5-я строка!"
```

### Специальные символы
Если значение перевода должно начинаться с `{}[],:` или с пробела, то перевод необходимо заключить в кавычки. В других ситуациях кавычки можно не использовать. Если значение требует точной `"`, можно использовать многострочный синтаксис:
```
ExamplePetBuff: {
	DisplayName: "{$Mods.ExampleMod.Common.PaperAirplane}"
	Description: '''"Пусть этот питомец будет для вас примером!"'''
}
```

### Особенности HJSON tModLoader

#### Цвет

`[c/color:text]` может отображать цветные тексты. 
Значение `color` представляет собой шестнадцатеричный цветовой код. 

Пример: 
```
Yes: "[c/008000:yes]"
No: "[c/FF0000:no]"
```
При этом «да» будет отображаться зелёным цветом, а «нет» - красным.

#### Предметы

`[i:ItemID]` и `[i:ItemClassName]` могут отображать предметы в сообщении.  
`ItemID` - это `type` предмета. Поскольку модицифицированные предметы не имеют фиксированного `type`, вместо него можно использовать `[i:ModName/ItemName]`.  
`ModName` - это имя класса вашей модификации, а `ItemName` - имя класса вашего предмета. 

`[i/pPrefixID:ItemID]` позволяет отобразить предмет с префиксом.  
`PrefixID` - это `type` префикса.  

`[i/sStack:ItemID]` может отображать предмет в определённой таблице ячеек.  
`Stack` - это количество предметов в таблице ячеек. 

Пример: 
```
Label: "[i:ImproveGame/StarburstWand] Пуск супермодели!"
Tooltip: "[i/p57:HiveBackpack] - забавный аксессуар, а [i/s1145:2] - просто грязь."
```
В этом примере `Label` будет отображать `(Значок жезла звёздной вспышки) Пуск супермодели!`, `StarburstWand` - это модифицированный предмет из Качества жизни.  
В `Tooltip` будет отображаться `рюкзак безжалостного улья` и `грязевой блок` в количестве по 1145. 

#### Привязка клавиш

`<KeybindName>` может отображать клавишу, привязанную к клавише.  
`KeybindName` - это имя привязанной клавиши. 

Пример: 
```
Tip: "Нажмите <right>, чтобы использовать специальную атаку"
```
`<right>` будет отображаться как клавиша, привязанная к правой клавише мыши.  

## Комментарии
Файлы `.hjson` могут содержать различные стили комментариев. tModLoader использует комментарии Hjson для передачи двух различных концепций. 

Комментарии, использующие `#` в начале строки, являются собственно комментариями, которые могут использоваться авторами модификаций для напоминания о полезных вещах. Эти комментарии должны располагаться непосредственно над ключом, к которому они относятся. Если не поместить комментарий над элементом, то при автоматическом обновлении файлов локализации в tModLoader он будет потерян или неправильно расположен.

Пример:
```
ExampleCanStackItem: {
	DisplayName: Example CanStack Item: Подарочный мешок
	# Ссылается на языковую клавишу с надписью «Нажмите правую кнопку мыши, чтобы открыть» на языке игры
	Tooltip: "{$CommonItemTooltip.RightClickToOpen}"
}
```

Эти комментарии будут скопированы из англоязычных файлов в другие, где они могут напоминать переводчикам о том, где, например, используются пользовательские ключи перевода.

Комментарии, использующие стиль `/* */` или `//` в начале строки, используются tModLoader для указания на то, что ключ на другом языке перевода ещё не переведён. Это служит индикатором для автора о том, на какие языки не хватает перевода. Переводчик может перевести значение перевода на свой язык и удалить синтаксис комментария. Авторы не должны использовать этот синтаксис для обычных комментариев, так как они будут потеряны при автоматическом обновлении файлов `.hjson` в игре.

## Translation File Names
tModLoader will attempt to load all `.hsjon` files in the mod as localization files. As such, localization files can be placed in any folder path, but by convention we recommend placing them in a folder named "Localization" at the root of your mod's source folder. The mod generator follows this convention and will generate `Localization/en-US.hjson` in your mod to get started.

A valid culture code must be present at the start of the file-name, or as the name of a containing folder to determine the language.

### Culture

The following languages, also known as cultures, are supported: English ("en-US"), German ("de-DE"), Italian ("it-IT"), French ("fr-FR"), Spanish ("es-ES"), Russian ("ru-RU"), Chinese ("zh-Hans"), Portuguese ("pt-BR"), or Polish ("pl-PL"). These codes are used to indicate which language the `.hjson` file pertains to. To start supporting a new language, see [Adding a new Language](#adding-a-new-language).

### Prefix
The prefix of a `.hjson` file indicates that all localization entries in the file share a common prefix. The most common usage of this is to omit the `Mods` and `ModNameHere` entries from localization files. By omitting these, the file is less indented and easier for some to work with. The vast majority of mods won't use localization values outside their mods prefix.

For example, a file called `Localization/en-US_Mods.ExampleMod.hjson` will inherit the `Mods.ExampleMod` prefix, meaning that the file can start directly with an entry for `Items`.

The pattern for this is as follows: The file path is split by folder, then by underscore. After culture is found, the next result will be used as the prefix. The following are all examples of options to indicate that a file is intended for English and should use the `Mods.ExampleMod` prefix.

```
Localization/en-US_Mods.ExampleMod.hjson
Localization/en-US/Mods.ExampleMod.hjson
en-US_Mods.ExampleMod.hjson
en-US/Mods.ExampleMod.hjson
Localization/CoolBoss/en-US_Mods.ExampleMod.hjson
```

## Multiple Files
Modders can use multiple `.hjson` files to organize their translations. For example, if a mod contained `en-US_Mods.ExampleMod.Items.hjson` and `en-US_Mods.ExampleMod.hjson`, the `en-US_Mods.ExampleMod.Items.hjson` file could contain all item localization while the other file contains the rest of the localization entries. New content will automatically end up in an existing `.hjson` file that has existing entries most similar to the translation key.

If you split up localization files, you only need to edit the English files and then build and reload the mod. The other languages will automatically adjust themselves to match the same layout.

# Adding new Translation Keys
Entries for new content will automatically populate the `.hjson` files, but custom translation keys can also be added to the files.

## Manually Adding Keys
To add custom keys, a modder can follow the `.hjson` syntax to add the localization entry directly. For example, ExampleMod has a category called "Common", these entries were all manually added as they are not used by tModLoader classes directly.

For example, lets start with this `.hjson` file:
```
Mods: {
	ExampleMod: {
    		Common: {
			PaperAirplane: Paper Airplane
		}
        
		Currencies.ExampleCustomCurrency: example currency
   	 }
}
```

We can add a new entry for a `Mods.ExampleMod.Common.NewKey` key by adding a line and following the `PaperAirplane` example. We can add a new category called `Uncommon` by following the syntax shown in the `Common` category. We can also add an entry that only takes a single line rather than specifying the category separately by following the `Currencies.ExampleCustomCurrency` example. The following shows each of these approaches:
```
Mods: {
	ExampleMod: {
    		Common: {
			PaperAirplane: Paper Airplane
        		HotDog: Hot dog
		}
        
 		Uncommon: {
            		Helicopter: Example Helicopter
       		}
        
		Currencies.ExampleCustomCurrency: example currency
        	Currencies.DirtCurrency: piles of dirt
    	}
}
```

Do note that when the localization files are automatically updated, tModLoader will decide how to organize and format the file, which will result in entries moving, but no data will be lost.


## Adding Localizable Properties
Modders can add `LocalizedText` properties to their classes, for a variety of purposes. When correctly implemented, these properties will automatically populate the `.hjson` files and be ready for localization work. 

[ExampleHealingPotion.cs](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Content/Items/Consumables/ExampleHealingPotion.cs) shows one such use for this. `ExampleHealingPotion` uses a `LocalizedText` property called `RestoreLifeText` that is used in a dynamic tooltip.

The basic approach is the following:
1. Add a static `LocalizedText` property to your class
2. Assign that property in `SetStaticDefaults` using `this.GetLocalization` method
3. Retrieve the localized text value when needed by accessing the property

For example:
```cs
public class ExampleHealingPotion : ModItem
{
	// Step 1: Make a static LocalizedText property
	public static LocalizedText RestoreLifeText { get; private set; }

	public override void SetStaticDefaults() {
		// Step 2: Assign RestoreLifeText to the result of GetLocalization
		RestoreLifeText = this.GetLocalization(nameof(RestoreLifeText));
	}

	public override void ModifyTooltips(List<TooltipLine> tooltips) {
		TooltipLine line = tooltips.FirstOrDefault(x => x.Mod == "Terraria" && x.Name == "HealLife");

		if (line != null) {
			// Change the text to 'Heals max/2 (max/4 when quick healing) life'
			// Step 3: Retrieve the localized text. This example uses the Format method because it has placeholders to populate, but the Value property could be used otherwise
			line.Text = Language.GetTextValue("CommonItemTooltip.RestoresLife", RestoreLifeText.Format(Main.LocalPlayer.statLifeMax2 / 2, Main.LocalPlayer.statLifeMax2 / 4));
		}
	}
}

```

In the above example, the `.hjson` file is automatically populated with an entry for `RestoreLifeText` alongside the existing `DisplayName` and `Tooltip` entries. The modder then updated it with the English text seen:
```
ExampleHealingPotion: {
	DisplayName: Example Healing Potion
	Tooltip: ""
	RestoreLifeText: "{0} ({1} when quick healing)"
}
```

**Note**
`LocalizedText` instances are meant to be statically stored. Ideally you should register and retrieve them once during loading. The `ExampleHealingPotion ` example does the registering in `SetStaticDefaults` and caches the retrieved `LocalizedText` into the `RestoreLifeText` property. If caching is too much effort, you can access the property every time you need it for a small performance cost. Note that for translations to be automatically populated to the `.hjson` files, you need to access the property at least once during load time.

### Retrieving text from Localizable Properties

In the class, the `LocalizedText` property can be used to display localized text to the user:

```cs
Main.NewText(SomeLocalizedTextProperty.Value);
```

If the text has placeholders, those can be populated with the `Format` method, which accepts as many arguments as there are placeholders:

```cs
Main.NewText(SomeLocalizedTextPropertyWithPlaceholders.Format(Main.LocalPlayer.statLifeMax2, Main.LocalPlayer.statManaMax2));
```

### Inheritable Localized Properties
When using inheritance, rather than a static property, a get-only property in the base class or a non-static property in the inheriting classes can be used to the same effect. The nature of inheritance allows logic and translations to be reused, keeping code and `.hjson` files clean and without needless repetition.

For example, imagine a base class shared by several items in a mod. A property can be added to the base class that holds the `LocalizedText` for each inheriting item. The property must be accessed during `SetStaticDefaults` for it to automatically appear in the `.hjson` files.

**Base class: MyBaseClass** 
```cs
public LocalizedText SpecialMessage => this.GetLocalization(nameof(SpecialMessage));

public override void SetStaticDefaults() {
	_ = SpecialMessage;
}
```

If classes `ClassA` and `ClassB` both inherit from `MyBaseClass`, then the `.hjson` file will be automatically populated with stub entries for the `SpecialMessage` key:

```
ClassA: {
	DisplayName: Class A 
	Tooltip: ""
	SpecialMessage: Mods.ExampleMod.Items.ClassA.SpecialMessage
}

ClassB: {
	DisplayName: Class B
	Tooltip: ""
	SpecialMessage: Mods.ExampleMod.Items.ClassB.SpecialMessage
}
```

If `ClassA` or `ClassB` override `SetStaticDefaults`, make sure to keep `base.SetStaticDefaults()` so the original code is executed.

The key `GetLocalization` generates will be of the form `Mods.{ModName}.{LocalizationCategory}.{ContentName}.{suffix}`. If a specific key outside the expected pattern is needed, a modder could use `Language.GetOrRegister("Full.Key.Here");` instead. Note that `GetLocalization` must be invoked prefixed by `this.` due to the design of C#, it can not be omitted. By using a full key in an inherited property, the shared localization can exist in a single common translation key, with inheriting classes that need their own key overriding the property and using their own key via `this.GetLocalization`.

### Another Example

[ExampleChest.cs](https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Content/Tiles/Furniture/ExampleChest.cs) serves as an example of using a custom key. By default, tModLoader will register a single translation key for each `ModTile` in the form `Mods.{ModName}.Tiles.{ContentName}.MapEntry`. This key makes it easy to add a map entry to a tile. (Map entries control the text shown to the user when the tile is hovered over in the fullscreen map.) `ExampleChest`, however, needs 2 map entries. Using `GetLocalization`, new keys can easily be added to the localization files:

```cs
AddMapEntry(new Color(200, 200, 200), this.GetLocalization("MapEntry0"), MapChestName);
AddMapEntry(new Color(0, 141, 63), this.GetLocalization("MapEntry1"), MapChestName);
```

The result of this code is that the localization file now contains these keys, ready for localizing into other languages:
```
ExampleChest: {
	MapEntry0: Example Chest
	MapEntry1: Locked Example Chest
}
```

Elsewhere in ExampleChest.cs, these localization keys are dynamically retrieved using `GetLocalization`:

```cs
public override LocalizedText DefaultContainerName(int frameX, int frameY) {
	int option = frameX / 36;
	return this.GetLocalization("MapEntry" + option);
}
```

This approach is useful for localization keys that are dynamic.

### ModType and ILocalizedModType
Mods implementing a custom `ModType` can implement `ILocalizedModType` to easily facilitate localization. This is as simple as adding `, ILocalizedModType` to the class inheritance and implementing the `LocalizationCategory` property by adding `public string LocalizationCategory => "MyModTypeCategory";`. For each `LocalizedText` in your custom `ModType` class, you can use `public virtual LocalizedText DisplayName => this.GetLocalization(nameof(DisplayName), PrettyPrintName);`, allowing them to be categorized properly in `.hjson` files as other existing `ModType` classes.

**In Depth:** `GetLocalization` is a helper method to simplify code and avoid typos. `GetLocalization` is equivalent to calling `Language.GetOrRegister` with the full key passed in. Similarly, `GetLocalizedValue` is equivalent to `Language.GetTextValue` in the same manner. `GetLocalizationKey` can be used to retrieve the generated key if desired.

`GetLocalization` and `Language.GetOrRegister` have an optional 2nd parameter named `makeDefaultValue` that defines a function that will be used to make the default value that will be assumed if the localization does not exist. For example, passing in `() => ""`, will result in the default value being an empty string rather than the key. Modders can pass in `PrettyPrintName` to achieve the typical behavior of taking the internal name of a piece of content and adding a space between capital letters. This approach should be used if the localization is optional, or you have a sensible default value for it.

# Adding a new Language
By default, tModLoader will only generate and update localization files for languages already appearing in `.hjson` files. To add a new language, simply make a text file and name it in the same manner as your existing localization files. You only need to make one. The file or folder path needs to contain the language code for the language: English ("en-US"), German ("de-DE"), Italian ("it-IT"), French ("fr-FR"), Spanish ("es-ES"), Russian ("ru-RU"), Chinese ("zh-Hans"), Portuguese ("pt-BR"), or Polish ("pl-PL"). Once the file is made and has the correct file extension, rebuilt the mod. The file will update with entries ready for translating. Other files will also be generated following the organization of the English hjson files.

Comments and organization of localization files other than English are all inherited from the English files. If you wish to add credits for translators, add them all to a comment at the top of the English files and they will propagate to the non-English files from there.

Modders can freely organize the English localization files to their liking and the other language files will update to match them. If you split up localization files, you only need to edit the English files and then build and reload the mod. The other languages will automatically adjust themselves to match the same layout. Keys removed from the English files will similarly result in the key being removed from other language files. In short, modders typically only need to touch the English files and the other language files will automatically adjust themselves.

---

```
Note to wiki editors: 
This page is NOT an exact translation of the original page. 
There are additions, deletions or modifications based on nature the target language. 
If you want to translate this page, you are suggested to refer to the original page. 
```

---

````
Translated by Blueberryy (theonlyoneblueberry on Discord). 
````